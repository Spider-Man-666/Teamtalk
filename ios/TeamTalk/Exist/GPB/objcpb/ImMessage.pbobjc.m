// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Message.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ImMessage.pbobjc.h"
 #import "ImBaseDefine.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImMessageRoot

@implementation ImMessageRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ImMessageRoot_FileDescriptor

static GPBFileDescriptor *ImMessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.Message"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - IMMsgData

@implementation IMMsgData

@dynamic hasFromUserId, fromUserId;
@dynamic hasToSessionId, toSessionId;
@dynamic hasMsgId, msgId;
@dynamic hasCreateTime, createTime;
@dynamic hasMsgType, msgType;
@dynamic hasMsgData, msgData;
@dynamic hasAttachData, attachData;

typedef struct IMMsgData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t toSessionId;
  uint32_t msgId;
  uint32_t createTime;
  MsgType msgType;
  NSData *msgData;
  NSData *attachData;
} IMMsgData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "fromUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgData_FieldNumber_FromUserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMMsgData__storage_, fromUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "toSessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgData_FieldNumber_ToSessionId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMMsgData__storage_, toSessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgData_FieldNumber_MsgId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMMsgData__storage_, msgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "createTime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgData_FieldNumber_CreateTime,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMMsgData__storage_, createTime),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = MsgType_MsgTypeSingleText,
        .core.name = "msgType",
        .core.dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .core.number = IMMsgData_FieldNumber_MsgType,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMMsgData__storage_, msgType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "msgData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgData_FieldNumber_MsgData,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(IMMsgData__storage_, msgData),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBytes,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgData_FieldNumber_AttachData,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(IMMsgData__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgData class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMMsgData__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMsgDataAck

@implementation IMMsgDataAck

@dynamic hasUserId, userId;
@dynamic hasSessionId, sessionId;
@dynamic hasMsgId, msgId;
@dynamic hasSessionType, sessionType;

typedef struct IMMsgDataAck__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t sessionId;
  uint32_t msgId;
  SessionType sessionType;
} IMMsgDataAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataAck_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMMsgDataAck__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataAck_FieldNumber_SessionId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMMsgDataAck__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataAck_FieldNumber_MsgId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMMsgDataAck__storage_, msgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMMsgDataAck_FieldNumber_SessionType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMMsgDataAck__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgDataAck class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMMsgDataAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMsgDataReadAck

@implementation IMMsgDataReadAck

@dynamic hasUserId, userId;
@dynamic hasSessionId, sessionId;
@dynamic hasMsgId, msgId;
@dynamic hasSessionType, sessionType;

typedef struct IMMsgDataReadAck__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t sessionId;
  uint32_t msgId;
  SessionType sessionType;
} IMMsgDataReadAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataReadAck_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataReadAck_FieldNumber_SessionId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataReadAck_FieldNumber_MsgId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, msgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMMsgDataReadAck_FieldNumber_SessionType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgDataReadAck class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMMsgDataReadAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMsgDataReadNotify

@implementation IMMsgDataReadNotify

@dynamic hasUserId, userId;
@dynamic hasSessionId, sessionId;
@dynamic hasMsgId, msgId;
@dynamic hasSessionType, sessionType;

typedef struct IMMsgDataReadNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t sessionId;
  uint32_t msgId;
  SessionType sessionType;
} IMMsgDataReadNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataReadNotify_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataReadNotify_FieldNumber_SessionId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMsgDataReadNotify_FieldNumber_MsgId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, msgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMMsgDataReadNotify_FieldNumber_SessionType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgDataReadNotify class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMMsgDataReadNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMClientTimeReq

@implementation IMClientTimeReq


typedef struct IMClientTimeReq__storage_ {
  uint32_t _has_storage_[1];
} IMClientTimeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMClientTimeReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(IMClientTimeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMClientTimeRsp

@implementation IMClientTimeRsp

@dynamic hasServerTime, serverTime;

typedef struct IMClientTimeRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t serverTime;
} IMClientTimeRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = IMClientTimeRsp_FieldNumber_ServerTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMClientTimeRsp__storage_, serverTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMClientTimeRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMClientTimeRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUnreadMsgCntReq

@implementation IMUnreadMsgCntReq

@dynamic hasUserId, userId;
@dynamic hasAttachData, attachData;

typedef struct IMUnreadMsgCntReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSData *attachData;
} IMUnreadMsgCntReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntReq_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUnreadMsgCntReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUnreadMsgCntReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUnreadMsgCntRsp

@implementation IMUnreadMsgCntRsp

@dynamic hasUserId, userId;
@dynamic hasTotalCnt, totalCnt;
@dynamic unreadinfoListArray, unreadinfoListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMUnreadMsgCntRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t totalCnt;
  NSMutableArray *unreadinfoListArray;
  NSData *attachData;
} IMUnreadMsgCntRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalCnt",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntRsp_FieldNumber_TotalCnt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, totalCnt),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unreadinfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UnreadInfo),
        .number = IMUnreadMsgCntRsp_FieldNumber_UnreadinfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, unreadinfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntRsp_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUnreadMsgCntRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUnreadMsgCntRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetMsgListReq

@implementation IMGetMsgListReq

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic hasMsgIdBegin, msgIdBegin;
@dynamic hasMsgCnt, msgCnt;
@dynamic hasAttachData, attachData;

typedef struct IMGetMsgListReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  uint32_t msgIdBegin;
  uint32_t msgCnt;
  NSData *attachData;
} IMGetMsgListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListReq_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMGetMsgListReq_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListReq_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgIdBegin",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListReq_FieldNumber_MsgIdBegin,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, msgIdBegin),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgCnt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListReq_FieldNumber_MsgCnt,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, msgCnt),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListReq_FieldNumber_AttachData,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgListReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMGetMsgListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetMsgListRsp

@implementation IMGetMsgListRsp

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic hasMsgIdBegin, msgIdBegin;
@dynamic msgListArray, msgListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMGetMsgListRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  uint32_t msgIdBegin;
  NSMutableArray *msgListArray;
  NSData *attachData;
} IMGetMsgListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListRsp_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMGetMsgListRsp_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListRsp_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgIdBegin",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListRsp_FieldNumber_MsgIdBegin,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, msgIdBegin),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "msgListArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MsgInfo),
        .core.number = IMGetMsgListRsp_FieldNumber_MsgListArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, msgListArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgListRsp_FieldNumber_AttachData,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgListRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMGetMsgListRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetLatestMsgIdReq

@implementation IMGetLatestMsgIdReq

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic hasAttachData, attachData;

typedef struct IMGetLatestMsgIdReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  NSData *attachData;
} IMGetLatestMsgIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetLatestMsgIdReq_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMGetLatestMsgIdReq_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetLatestMsgIdReq_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetLatestMsgIdReq_FieldNumber_AttachData,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetLatestMsgIdReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMGetLatestMsgIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetLatestMsgIdRsp

@implementation IMGetLatestMsgIdRsp

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic hasLatestMsgId, latestMsgId;
@dynamic hasAttachData, attachData;

typedef struct IMGetLatestMsgIdRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  uint32_t latestMsgId;
  NSData *attachData;
} IMGetLatestMsgIdRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetLatestMsgIdRsp_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMGetLatestMsgIdRsp_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetLatestMsgIdRsp_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "latestMsgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetLatestMsgIdRsp_FieldNumber_LatestMsgId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, latestMsgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetLatestMsgIdRsp_FieldNumber_AttachData,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetLatestMsgIdRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMGetLatestMsgIdRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetMsgByIdReq

@implementation IMGetMsgByIdReq

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic msgIdListArray, msgIdListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMGetMsgByIdReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  GPBUInt32Array *msgIdListArray;
  NSData *attachData;
} IMGetMsgByIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgByIdReq_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMGetMsgByIdReq_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgByIdReq_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "msgIdListArray",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgByIdReq_FieldNumber_MsgIdListArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, msgIdListArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgByIdReq_FieldNumber_AttachData,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgByIdReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMGetMsgByIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetMsgByIdRsp

@implementation IMGetMsgByIdRsp

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic msgListArray, msgListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMGetMsgByIdRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  NSMutableArray *msgListArray;
  NSData *attachData;
} IMGetMsgByIdRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgByIdRsp_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMGetMsgByIdRsp_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgByIdRsp_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "msgListArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MsgInfo),
        .core.number = IMGetMsgByIdRsp_FieldNumber_MsgListArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, msgListArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMGetMsgByIdRsp_FieldNumber_AttachData,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgByIdRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMGetMsgByIdRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
