// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Message.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ImMessage.pbobjc.h"
 #import "ImBaseDefine.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImMessageRoot

@implementation ImMessageRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ImMessageRoot_FileDescriptor

static GPBFileDescriptor *ImMessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.Message"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - IMMsgData

@implementation IMMsgData

@dynamic fromUserId;
@dynamic toSessionId;
@dynamic msgId;
@dynamic createTime;
@dynamic msgType;
@dynamic msgData;
@dynamic attachData;

typedef struct IMMsgData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t toSessionId;
  uint32_t msgId;
  uint32_t createTime;
  MsgType msgType;
  NSData *msgData;
  NSData *attachData;
} IMMsgData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgData_FieldNumber_FromUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMsgData__storage_, fromUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toSessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgData_FieldNumber_ToSessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMsgData__storage_, toSessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgData_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMMsgData__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgData_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMMsgData__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .number = IMMsgData_FieldNumber_MsgType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMMsgData__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgData",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgData_FieldNumber_MsgData,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IMMsgData__storage_, msgData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgData_FieldNumber_AttachData,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(IMMsgData__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgData class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMsgData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMMsgData_MsgType_RawValue(IMMsgData *message) {
  GPBDescriptor *descriptor = [IMMsgData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgData_FieldNumber_MsgType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMMsgData_MsgType_RawValue(IMMsgData *message, int32_t value) {
  GPBDescriptor *descriptor = [IMMsgData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgData_FieldNumber_MsgType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMMsgDataAck

@implementation IMMsgDataAck

@dynamic userId;
@dynamic sessionId;
@dynamic msgId;
@dynamic sessionType;

typedef struct IMMsgDataAck__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t sessionId;
  uint32_t msgId;
  SessionType sessionType;
} IMMsgDataAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataAck_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMsgDataAck__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataAck_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMsgDataAck__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataAck_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMMsgDataAck__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMMsgDataAck_FieldNumber_SessionType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMMsgDataAck__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgDataAck class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMsgDataAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMMsgDataAck_SessionType_RawValue(IMMsgDataAck *message) {
  GPBDescriptor *descriptor = [IMMsgDataAck descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgDataAck_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMMsgDataAck_SessionType_RawValue(IMMsgDataAck *message, int32_t value) {
  GPBDescriptor *descriptor = [IMMsgDataAck descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgDataAck_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMMsgDataReadAck

@implementation IMMsgDataReadAck

@dynamic userId;
@dynamic sessionId;
@dynamic msgId;
@dynamic sessionType;

typedef struct IMMsgDataReadAck__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t sessionId;
  uint32_t msgId;
  SessionType sessionType;
} IMMsgDataReadAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataReadAck_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataReadAck_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataReadAck_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMMsgDataReadAck_FieldNumber_SessionType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMMsgDataReadAck__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgDataReadAck class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMsgDataReadAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMMsgDataReadAck_SessionType_RawValue(IMMsgDataReadAck *message) {
  GPBDescriptor *descriptor = [IMMsgDataReadAck descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgDataReadAck_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMMsgDataReadAck_SessionType_RawValue(IMMsgDataReadAck *message, int32_t value) {
  GPBDescriptor *descriptor = [IMMsgDataReadAck descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgDataReadAck_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMMsgDataReadNotify

@implementation IMMsgDataReadNotify

@dynamic userId;
@dynamic sessionId;
@dynamic msgId;
@dynamic sessionType;

typedef struct IMMsgDataReadNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t sessionId;
  uint32_t msgId;
  SessionType sessionType;
} IMMsgDataReadNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataReadNotify_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataReadNotify_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgDataReadNotify_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMMsgDataReadNotify_FieldNumber_SessionType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMMsgDataReadNotify__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgDataReadNotify class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMsgDataReadNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMMsgDataReadNotify_SessionType_RawValue(IMMsgDataReadNotify *message) {
  GPBDescriptor *descriptor = [IMMsgDataReadNotify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgDataReadNotify_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMMsgDataReadNotify_SessionType_RawValue(IMMsgDataReadNotify *message, int32_t value) {
  GPBDescriptor *descriptor = [IMMsgDataReadNotify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMMsgDataReadNotify_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMClientTimeReq

@implementation IMClientTimeReq


typedef struct IMClientTimeReq__storage_ {
  uint32_t _has_storage_[1];
} IMClientTimeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMClientTimeReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(IMClientTimeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMClientTimeRsp

@implementation IMClientTimeRsp

@dynamic serverTime;

typedef struct IMClientTimeRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t serverTime;
} IMClientTimeRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = IMClientTimeRsp_FieldNumber_ServerTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMClientTimeRsp__storage_, serverTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMClientTimeRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMClientTimeRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUnreadMsgCntReq

@implementation IMUnreadMsgCntReq

@dynamic userId;
@dynamic attachData;

typedef struct IMUnreadMsgCntReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSData *attachData;
} IMUnreadMsgCntReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntReq_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUnreadMsgCntReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUnreadMsgCntReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUnreadMsgCntRsp

@implementation IMUnreadMsgCntRsp

@dynamic userId;
@dynamic totalCnt;
@dynamic unreadinfoListArray, unreadinfoListArray_Count;
@dynamic attachData;

typedef struct IMUnreadMsgCntRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t totalCnt;
  NSMutableArray *unreadinfoListArray;
  NSData *attachData;
} IMUnreadMsgCntRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalCnt",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntRsp_FieldNumber_TotalCnt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, totalCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unreadinfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UnreadInfo),
        .number = IMUnreadMsgCntRsp_FieldNumber_UnreadinfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, unreadinfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUnreadMsgCntRsp_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMUnreadMsgCntRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUnreadMsgCntRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUnreadMsgCntRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetMsgListReq

@implementation IMGetMsgListReq

@dynamic userId;
@dynamic sessionType;
@dynamic sessionId;
@dynamic msgIdBegin;
@dynamic msgCnt;
@dynamic attachData;

typedef struct IMGetMsgListReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  uint32_t msgIdBegin;
  uint32_t msgCnt;
  NSData *attachData;
} IMGetMsgListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMGetMsgListReq_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListReq_FieldNumber_SessionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgIdBegin",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListReq_FieldNumber_MsgIdBegin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, msgIdBegin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgCnt",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListReq_FieldNumber_MsgCnt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, msgCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListReq_FieldNumber_AttachData,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IMGetMsgListReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgListReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetMsgListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMGetMsgListReq_SessionType_RawValue(IMGetMsgListReq *message) {
  GPBDescriptor *descriptor = [IMGetMsgListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgListReq_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMGetMsgListReq_SessionType_RawValue(IMGetMsgListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [IMGetMsgListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgListReq_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMGetMsgListRsp

@implementation IMGetMsgListRsp

@dynamic userId;
@dynamic sessionType;
@dynamic sessionId;
@dynamic msgIdBegin;
@dynamic msgListArray, msgListArray_Count;
@dynamic attachData;

typedef struct IMGetMsgListRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  uint32_t msgIdBegin;
  NSMutableArray *msgListArray;
  NSData *attachData;
} IMGetMsgListRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMGetMsgListRsp_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListRsp_FieldNumber_SessionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgIdBegin",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListRsp_FieldNumber_MsgIdBegin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, msgIdBegin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MsgInfo),
        .number = IMGetMsgListRsp_FieldNumber_MsgListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, msgListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgListRsp_FieldNumber_AttachData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMGetMsgListRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgListRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetMsgListRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMGetMsgListRsp_SessionType_RawValue(IMGetMsgListRsp *message) {
  GPBDescriptor *descriptor = [IMGetMsgListRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgListRsp_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMGetMsgListRsp_SessionType_RawValue(IMGetMsgListRsp *message, int32_t value) {
  GPBDescriptor *descriptor = [IMGetMsgListRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgListRsp_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMGetLatestMsgIdReq

@implementation IMGetLatestMsgIdReq

@dynamic userId;
@dynamic sessionType;
@dynamic sessionId;
@dynamic attachData;

typedef struct IMGetLatestMsgIdReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  NSData *attachData;
} IMGetLatestMsgIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetLatestMsgIdReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMGetLatestMsgIdReq_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetLatestMsgIdReq_FieldNumber_SessionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetLatestMsgIdReq_FieldNumber_AttachData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetLatestMsgIdReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetLatestMsgIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMGetLatestMsgIdReq_SessionType_RawValue(IMGetLatestMsgIdReq *message) {
  GPBDescriptor *descriptor = [IMGetLatestMsgIdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetLatestMsgIdReq_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMGetLatestMsgIdReq_SessionType_RawValue(IMGetLatestMsgIdReq *message, int32_t value) {
  GPBDescriptor *descriptor = [IMGetLatestMsgIdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetLatestMsgIdReq_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMGetLatestMsgIdRsp

@implementation IMGetLatestMsgIdRsp

@dynamic userId;
@dynamic sessionType;
@dynamic sessionId;
@dynamic latestMsgId;
@dynamic attachData;

typedef struct IMGetLatestMsgIdRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  uint32_t latestMsgId;
  NSData *attachData;
} IMGetLatestMsgIdRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetLatestMsgIdRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMGetLatestMsgIdRsp_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetLatestMsgIdRsp_FieldNumber_SessionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestMsgId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetLatestMsgIdRsp_FieldNumber_LatestMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, latestMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetLatestMsgIdRsp_FieldNumber_AttachData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMGetLatestMsgIdRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetLatestMsgIdRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetLatestMsgIdRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMGetLatestMsgIdRsp_SessionType_RawValue(IMGetLatestMsgIdRsp *message) {
  GPBDescriptor *descriptor = [IMGetLatestMsgIdRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetLatestMsgIdRsp_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMGetLatestMsgIdRsp_SessionType_RawValue(IMGetLatestMsgIdRsp *message, int32_t value) {
  GPBDescriptor *descriptor = [IMGetLatestMsgIdRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetLatestMsgIdRsp_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMGetMsgByIdReq

@implementation IMGetMsgByIdReq

@dynamic userId;
@dynamic sessionType;
@dynamic sessionId;
@dynamic msgIdListArray, msgIdListArray_Count;
@dynamic attachData;

typedef struct IMGetMsgByIdReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  GPBUInt32Array *msgIdListArray;
  NSData *attachData;
} IMGetMsgByIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgByIdReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMGetMsgByIdReq_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgByIdReq_FieldNumber_SessionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgIdListArray",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgByIdReq_FieldNumber_MsgIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, msgIdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgByIdReq_FieldNumber_AttachData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMGetMsgByIdReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgByIdReq class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetMsgByIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMGetMsgByIdReq_SessionType_RawValue(IMGetMsgByIdReq *message) {
  GPBDescriptor *descriptor = [IMGetMsgByIdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgByIdReq_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMGetMsgByIdReq_SessionType_RawValue(IMGetMsgByIdReq *message, int32_t value) {
  GPBDescriptor *descriptor = [IMGetMsgByIdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgByIdReq_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMGetMsgByIdRsp

@implementation IMGetMsgByIdRsp

@dynamic userId;
@dynamic sessionType;
@dynamic sessionId;
@dynamic msgListArray, msgListArray_Count;
@dynamic attachData;

typedef struct IMGetMsgByIdRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  NSMutableArray *msgListArray;
  NSData *attachData;
} IMGetMsgByIdRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgByIdRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionType",
        .dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .number = IMGetMsgByIdRsp_FieldNumber_SessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgByIdRsp_FieldNumber_SessionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MsgInfo),
        .number = IMGetMsgByIdRsp_FieldNumber_MsgListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, msgListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetMsgByIdRsp_FieldNumber_AttachData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMGetMsgByIdRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetMsgByIdRsp class]
                                     rootClass:[ImMessageRoot class]
                                          file:ImMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetMsgByIdRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMGetMsgByIdRsp_SessionType_RawValue(IMGetMsgByIdRsp *message) {
  GPBDescriptor *descriptor = [IMGetMsgByIdRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgByIdRsp_FieldNumber_SessionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMGetMsgByIdRsp_SessionType_RawValue(IMGetMsgByIdRsp *message, int32_t value) {
  GPBDescriptor *descriptor = [IMGetMsgByIdRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMGetMsgByIdRsp_FieldNumber_SessionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
