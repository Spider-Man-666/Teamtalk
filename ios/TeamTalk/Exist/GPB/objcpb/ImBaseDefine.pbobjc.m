// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ImBaseDefine.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImBaseDefineRoot

@implementation ImBaseDefineRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ImBaseDefineRoot_FileDescriptor

static GPBFileDescriptor *ImBaseDefineRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.BaseDefine"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum ServiceID

GPBEnumDescriptor *ServiceID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SidLogin\000SidBuddyList\000SidMsg\000SidGroup\000Si"
        "dFile\000SidSwitchService\000SidOther\000SidInter"
        "nal\000";
    static const int32_t values[] = {
        ServiceID_SidLogin,
        ServiceID_SidBuddyList,
        ServiceID_SidMsg,
        ServiceID_SidGroup,
        ServiceID_SidFile,
        ServiceID_SidSwitchService,
        ServiceID_SidOther,
        ServiceID_SidInternal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ServiceID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ServiceID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ServiceID_IsValidValue(int32_t value__) {
  switch (value__) {
    case ServiceID_SidLogin:
    case ServiceID_SidBuddyList:
    case ServiceID_SidMsg:
    case ServiceID_SidGroup:
    case ServiceID_SidFile:
    case ServiceID_SidSwitchService:
    case ServiceID_SidOther:
    case ServiceID_SidInternal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum LoginCmdID

GPBEnumDescriptor *LoginCmdID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CidLoginReqMsgserver\000CidLoginResMsgserve"
        "r\000CidLoginReqUserlogin\000CidLoginResUserlo"
        "gin\000CidLoginReqLoginout\000CidLoginResLogin"
        "out\000CidLoginKickUser\000CidLoginReqDeviceto"
        "ken\000CidLoginResDevicetoken\000CidLoginReqKi"
        "ckpcclient\000CidLoginResKickpcclient\000CidLo"
        "ginReqPushShield\000CidLoginResPushShield\000C"
        "idLoginReqQueryPushShield\000CidLoginResQue"
        "ryPushShield\000";
    static const int32_t values[] = {
        LoginCmdID_CidLoginReqMsgserver,
        LoginCmdID_CidLoginResMsgserver,
        LoginCmdID_CidLoginReqUserlogin,
        LoginCmdID_CidLoginResUserlogin,
        LoginCmdID_CidLoginReqLoginout,
        LoginCmdID_CidLoginResLoginout,
        LoginCmdID_CidLoginKickUser,
        LoginCmdID_CidLoginReqDevicetoken,
        LoginCmdID_CidLoginResDevicetoken,
        LoginCmdID_CidLoginReqKickpcclient,
        LoginCmdID_CidLoginResKickpcclient,
        LoginCmdID_CidLoginReqPushShield,
        LoginCmdID_CidLoginResPushShield,
        LoginCmdID_CidLoginReqQueryPushShield,
        LoginCmdID_CidLoginResQueryPushShield,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LoginCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LoginCmdID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LoginCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case LoginCmdID_CidLoginReqMsgserver:
    case LoginCmdID_CidLoginResMsgserver:
    case LoginCmdID_CidLoginReqUserlogin:
    case LoginCmdID_CidLoginResUserlogin:
    case LoginCmdID_CidLoginReqLoginout:
    case LoginCmdID_CidLoginResLoginout:
    case LoginCmdID_CidLoginKickUser:
    case LoginCmdID_CidLoginReqDevicetoken:
    case LoginCmdID_CidLoginResDevicetoken:
    case LoginCmdID_CidLoginReqKickpcclient:
    case LoginCmdID_CidLoginResKickpcclient:
    case LoginCmdID_CidLoginReqPushShield:
    case LoginCmdID_CidLoginResPushShield:
    case LoginCmdID_CidLoginReqQueryPushShield:
    case LoginCmdID_CidLoginResQueryPushShield:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BuddyListCmdID

GPBEnumDescriptor *BuddyListCmdID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CidBuddyListRecentContactSessionRequest\000"
        "CidBuddyListRecentContactSessionResponse"
        "\000CidBuddyListStatusNotify\000CidBuddyListUs"
        "erInfoRequest\000CidBuddyListUserInfoRespon"
        "se\000CidBuddyListRemoveSessionReq\000CidBuddy"
        "ListRemoveSessionRes\000CidBuddyListAllUser"
        "Request\000CidBuddyListAllUserResponse\000CidB"
        "uddyListUsersStatusRequest\000CidBuddyListU"
        "sersStatusResponse\000CidBuddyListChangeAva"
        "tarRequest\000CidBuddyListChangeAvatarRespo"
        "nse\000CidBuddyListPcLoginStatusNotify\000CidB"
        "uddyListRemoveSessionNotify\000CidBuddyList"
        "DepartmentRequest\000CidBuddyListDepartment"
        "Response\000CidBuddyListAvatarChangedNotify"
        "\000CidBuddyListChangeSignInfoRequest\000CidBu"
        "ddyListChangeSignInfoResponse\000CidBuddyLi"
        "stSignInfoChangedNotify\000";
    static const int32_t values[] = {
        BuddyListCmdID_CidBuddyListRecentContactSessionRequest,
        BuddyListCmdID_CidBuddyListRecentContactSessionResponse,
        BuddyListCmdID_CidBuddyListStatusNotify,
        BuddyListCmdID_CidBuddyListUserInfoRequest,
        BuddyListCmdID_CidBuddyListUserInfoResponse,
        BuddyListCmdID_CidBuddyListRemoveSessionReq,
        BuddyListCmdID_CidBuddyListRemoveSessionRes,
        BuddyListCmdID_CidBuddyListAllUserRequest,
        BuddyListCmdID_CidBuddyListAllUserResponse,
        BuddyListCmdID_CidBuddyListUsersStatusRequest,
        BuddyListCmdID_CidBuddyListUsersStatusResponse,
        BuddyListCmdID_CidBuddyListChangeAvatarRequest,
        BuddyListCmdID_CidBuddyListChangeAvatarResponse,
        BuddyListCmdID_CidBuddyListPcLoginStatusNotify,
        BuddyListCmdID_CidBuddyListRemoveSessionNotify,
        BuddyListCmdID_CidBuddyListDepartmentRequest,
        BuddyListCmdID_CidBuddyListDepartmentResponse,
        BuddyListCmdID_CidBuddyListAvatarChangedNotify,
        BuddyListCmdID_CidBuddyListChangeSignInfoRequest,
        BuddyListCmdID_CidBuddyListChangeSignInfoResponse,
        BuddyListCmdID_CidBuddyListSignInfoChangedNotify,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BuddyListCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BuddyListCmdID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BuddyListCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case BuddyListCmdID_CidBuddyListRecentContactSessionRequest:
    case BuddyListCmdID_CidBuddyListRecentContactSessionResponse:
    case BuddyListCmdID_CidBuddyListStatusNotify:
    case BuddyListCmdID_CidBuddyListUserInfoRequest:
    case BuddyListCmdID_CidBuddyListUserInfoResponse:
    case BuddyListCmdID_CidBuddyListRemoveSessionReq:
    case BuddyListCmdID_CidBuddyListRemoveSessionRes:
    case BuddyListCmdID_CidBuddyListAllUserRequest:
    case BuddyListCmdID_CidBuddyListAllUserResponse:
    case BuddyListCmdID_CidBuddyListUsersStatusRequest:
    case BuddyListCmdID_CidBuddyListUsersStatusResponse:
    case BuddyListCmdID_CidBuddyListChangeAvatarRequest:
    case BuddyListCmdID_CidBuddyListChangeAvatarResponse:
    case BuddyListCmdID_CidBuddyListPcLoginStatusNotify:
    case BuddyListCmdID_CidBuddyListRemoveSessionNotify:
    case BuddyListCmdID_CidBuddyListDepartmentRequest:
    case BuddyListCmdID_CidBuddyListDepartmentResponse:
    case BuddyListCmdID_CidBuddyListAvatarChangedNotify:
    case BuddyListCmdID_CidBuddyListChangeSignInfoRequest:
    case BuddyListCmdID_CidBuddyListChangeSignInfoResponse:
    case BuddyListCmdID_CidBuddyListSignInfoChangedNotify:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageCmdID

GPBEnumDescriptor *MessageCmdID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CidMsgData\000CidMsgDataAck\000CidMsgReadAck\000C"
        "idMsgReadNotify\000CidMsgTimeRequest\000CidMsg"
        "TimeResponse\000CidMsgUnreadCntRequest\000CidM"
        "sgUnreadCntResponse\000CidMsgListRequest\000Ci"
        "dMsgListResponse\000CidMsgGetLatestMsgIdReq"
        "\000CidMsgGetLatestMsgIdRsp\000CidMsgGetByMsgI"
        "dReq\000CidMsgGetByMsgIdRes\000";
    static const int32_t values[] = {
        MessageCmdID_CidMsgData,
        MessageCmdID_CidMsgDataAck,
        MessageCmdID_CidMsgReadAck,
        MessageCmdID_CidMsgReadNotify,
        MessageCmdID_CidMsgTimeRequest,
        MessageCmdID_CidMsgTimeResponse,
        MessageCmdID_CidMsgUnreadCntRequest,
        MessageCmdID_CidMsgUnreadCntResponse,
        MessageCmdID_CidMsgListRequest,
        MessageCmdID_CidMsgListResponse,
        MessageCmdID_CidMsgGetLatestMsgIdReq,
        MessageCmdID_CidMsgGetLatestMsgIdRsp,
        MessageCmdID_CidMsgGetByMsgIdReq,
        MessageCmdID_CidMsgGetByMsgIdRes,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageCmdID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageCmdID_CidMsgData:
    case MessageCmdID_CidMsgDataAck:
    case MessageCmdID_CidMsgReadAck:
    case MessageCmdID_CidMsgReadNotify:
    case MessageCmdID_CidMsgTimeRequest:
    case MessageCmdID_CidMsgTimeResponse:
    case MessageCmdID_CidMsgUnreadCntRequest:
    case MessageCmdID_CidMsgUnreadCntResponse:
    case MessageCmdID_CidMsgListRequest:
    case MessageCmdID_CidMsgListResponse:
    case MessageCmdID_CidMsgGetLatestMsgIdReq:
    case MessageCmdID_CidMsgGetLatestMsgIdRsp:
    case MessageCmdID_CidMsgGetByMsgIdReq:
    case MessageCmdID_CidMsgGetByMsgIdRes:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GroupCmdID

GPBEnumDescriptor *GroupCmdID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CidGroupNormalListRequest\000CidGroupNormal"
        "ListResponse\000CidGroupInfoRequest\000CidGrou"
        "pInfoResponse\000CidGroupCreateRequest\000CidG"
        "roupCreateResponse\000CidGroupChangeMemberR"
        "equest\000CidGroupChangeMemberResponse\000CidG"
        "roupShieldGroupRequest\000CidGroupShieldGro"
        "upResponse\000CidGroupChangeMemberNotify\000";
    static const int32_t values[] = {
        GroupCmdID_CidGroupNormalListRequest,
        GroupCmdID_CidGroupNormalListResponse,
        GroupCmdID_CidGroupInfoRequest,
        GroupCmdID_CidGroupInfoResponse,
        GroupCmdID_CidGroupCreateRequest,
        GroupCmdID_CidGroupCreateResponse,
        GroupCmdID_CidGroupChangeMemberRequest,
        GroupCmdID_CidGroupChangeMemberResponse,
        GroupCmdID_CidGroupShieldGroupRequest,
        GroupCmdID_CidGroupShieldGroupResponse,
        GroupCmdID_CidGroupChangeMemberNotify,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupCmdID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupCmdID_CidGroupNormalListRequest:
    case GroupCmdID_CidGroupNormalListResponse:
    case GroupCmdID_CidGroupInfoRequest:
    case GroupCmdID_CidGroupInfoResponse:
    case GroupCmdID_CidGroupCreateRequest:
    case GroupCmdID_CidGroupCreateResponse:
    case GroupCmdID_CidGroupChangeMemberRequest:
    case GroupCmdID_CidGroupChangeMemberResponse:
    case GroupCmdID_CidGroupShieldGroupRequest:
    case GroupCmdID_CidGroupShieldGroupResponse:
    case GroupCmdID_CidGroupChangeMemberNotify:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileCmdID

GPBEnumDescriptor *FileCmdID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CidFileLoginReq\000CidFileLoginRes\000CidFileS"
        "tate\000CidFilePullDataReq\000CidFilePullDataR"
        "sp\000CidFileRequest\000CidFileResponse\000CidFil"
        "eNotify\000CidFileHasOfflineReq\000CidFileHasO"
        "fflineRes\000CidFileAddOfflineReq\000CidFileDe"
        "lOfflineReq\000";
    static const int32_t values[] = {
        FileCmdID_CidFileLoginReq,
        FileCmdID_CidFileLoginRes,
        FileCmdID_CidFileState,
        FileCmdID_CidFilePullDataReq,
        FileCmdID_CidFilePullDataRsp,
        FileCmdID_CidFileRequest,
        FileCmdID_CidFileResponse,
        FileCmdID_CidFileNotify,
        FileCmdID_CidFileHasOfflineReq,
        FileCmdID_CidFileHasOfflineRes,
        FileCmdID_CidFileAddOfflineReq,
        FileCmdID_CidFileDelOfflineReq,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileCmdID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileCmdID_CidFileLoginReq:
    case FileCmdID_CidFileLoginRes:
    case FileCmdID_CidFileState:
    case FileCmdID_CidFilePullDataReq:
    case FileCmdID_CidFilePullDataRsp:
    case FileCmdID_CidFileRequest:
    case FileCmdID_CidFileResponse:
    case FileCmdID_CidFileNotify:
    case FileCmdID_CidFileHasOfflineReq:
    case FileCmdID_CidFileHasOfflineRes:
    case FileCmdID_CidFileAddOfflineReq:
    case FileCmdID_CidFileDelOfflineReq:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SwitchServiceCmdID

GPBEnumDescriptor *SwitchServiceCmdID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CidSwitchP2PCmd\000";
    static const int32_t values[] = {
        SwitchServiceCmdID_CidSwitchP2PCmd,
    };
    static const char *extraTextFormatInfo = "\001\000c\346\203\343\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SwitchServiceCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SwitchServiceCmdID_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SwitchServiceCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case SwitchServiceCmdID_CidSwitchP2PCmd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OtherCmdID

GPBEnumDescriptor *OtherCmdID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CidOtherHeartbeat\000CidOtherStopRecvPacket"
        "\000CidOtherValidateReq\000CidOtherValidateRsp"
        "\000CidOtherGetDeviceTokenReq\000CidOtherGetDe"
        "viceTokenRsp\000CidOtherRoleSet\000CidOtherOnl"
        "ineUserInfo\000CidOtherMsgServInfo\000CidOther"
        "UserStatusUpdate\000CidOtherUserCntUpdate\000C"
        "idOtherServerKickUser\000CidOtherLoginStatu"
        "sNotify\000CidOtherPushToUserReq\000CidOtherPu"
        "shToUserRsp\000CidOtherGetShieldReq\000CidOthe"
        "rGetShieldRsp\000CidOtherFileTransferReq\000Ci"
        "dOtherFileTransferRsp\000CidOtherFileServer"
        "IpReq\000CidOtherFileServerIpRsp\000";
    static const int32_t values[] = {
        OtherCmdID_CidOtherHeartbeat,
        OtherCmdID_CidOtherStopRecvPacket,
        OtherCmdID_CidOtherValidateReq,
        OtherCmdID_CidOtherValidateRsp,
        OtherCmdID_CidOtherGetDeviceTokenReq,
        OtherCmdID_CidOtherGetDeviceTokenRsp,
        OtherCmdID_CidOtherRoleSet,
        OtherCmdID_CidOtherOnlineUserInfo,
        OtherCmdID_CidOtherMsgServInfo,
        OtherCmdID_CidOtherUserStatusUpdate,
        OtherCmdID_CidOtherUserCntUpdate,
        OtherCmdID_CidOtherServerKickUser,
        OtherCmdID_CidOtherLoginStatusNotify,
        OtherCmdID_CidOtherPushToUserReq,
        OtherCmdID_CidOtherPushToUserRsp,
        OtherCmdID_CidOtherGetShieldReq,
        OtherCmdID_CidOtherGetShieldRsp,
        OtherCmdID_CidOtherFileTransferReq,
        OtherCmdID_CidOtherFileTransferRsp,
        OtherCmdID_CidOtherFileServerIpReq,
        OtherCmdID_CidOtherFileServerIpRsp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OtherCmdID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OtherCmdID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OtherCmdID_IsValidValue(int32_t value__) {
  switch (value__) {
    case OtherCmdID_CidOtherHeartbeat:
    case OtherCmdID_CidOtherStopRecvPacket:
    case OtherCmdID_CidOtherValidateReq:
    case OtherCmdID_CidOtherValidateRsp:
    case OtherCmdID_CidOtherGetDeviceTokenReq:
    case OtherCmdID_CidOtherGetDeviceTokenRsp:
    case OtherCmdID_CidOtherRoleSet:
    case OtherCmdID_CidOtherOnlineUserInfo:
    case OtherCmdID_CidOtherMsgServInfo:
    case OtherCmdID_CidOtherUserStatusUpdate:
    case OtherCmdID_CidOtherUserCntUpdate:
    case OtherCmdID_CidOtherServerKickUser:
    case OtherCmdID_CidOtherLoginStatusNotify:
    case OtherCmdID_CidOtherPushToUserReq:
    case OtherCmdID_CidOtherPushToUserRsp:
    case OtherCmdID_CidOtherGetShieldReq:
    case OtherCmdID_CidOtherGetShieldRsp:
    case OtherCmdID_CidOtherFileTransferReq:
    case OtherCmdID_CidOtherFileTransferRsp:
    case OtherCmdID_CidOtherFileServerIpReq:
    case OtherCmdID_CidOtherFileServerIpRsp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResultType

GPBEnumDescriptor *ResultType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "RefuseReasonNone\000RefuseReasonNoMsgServer"
        "\000RefuseReasonMsgServerFull\000RefuseReasonN"
        "oDbServer\000RefuseReasonNoLoginServer\000Refu"
        "seReasonNoRouteServer\000RefuseReasonDbVali"
        "dateFailed\000RefuseReasonVersionTooOld\000";
    static const int32_t values[] = {
        ResultType_RefuseReasonNone,
        ResultType_RefuseReasonNoMsgServer,
        ResultType_RefuseReasonMsgServerFull,
        ResultType_RefuseReasonNoDbServer,
        ResultType_RefuseReasonNoLoginServer,
        ResultType_RefuseReasonNoRouteServer,
        ResultType_RefuseReasonDbValidateFailed,
        ResultType_RefuseReasonVersionTooOld,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResultType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResultType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResultType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResultType_RefuseReasonNone:
    case ResultType_RefuseReasonNoMsgServer:
    case ResultType_RefuseReasonMsgServerFull:
    case ResultType_RefuseReasonNoDbServer:
    case ResultType_RefuseReasonNoLoginServer:
    case ResultType_RefuseReasonNoRouteServer:
    case ResultType_RefuseReasonDbValidateFailed:
    case ResultType_RefuseReasonVersionTooOld:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum KickReasonType

GPBEnumDescriptor *KickReasonType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "KickReasonDuplicateUser\000KickReasonMobile"
        "Kick\000";
    static const int32_t values[] = {
        KickReasonType_KickReasonDuplicateUser,
        KickReasonType_KickReasonMobileKick,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KickReasonType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KickReasonType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KickReasonType_IsValidValue(int32_t value__) {
  switch (value__) {
    case KickReasonType_KickReasonDuplicateUser:
    case KickReasonType_KickReasonMobileKick:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OnlineListType

GPBEnumDescriptor *OnlineListType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "OnlineListTypeFriendList\000";
    static const int32_t values[] = {
        OnlineListType_OnlineListTypeFriendList,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OnlineListType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OnlineListType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OnlineListType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OnlineListType_OnlineListTypeFriendList:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UserStatType

GPBEnumDescriptor *UserStatType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UserStatusOnline\000UserStatusOffline\000UserS"
        "tatusLeave\000";
    static const int32_t values[] = {
        UserStatType_UserStatusOnline,
        UserStatType_UserStatusOffline,
        UserStatType_UserStatusLeave,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserStatType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserStatType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserStatType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserStatType_UserStatusOnline:
    case UserStatType_UserStatusOffline:
    case UserStatType_UserStatusLeave:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SessionType

GPBEnumDescriptor *SessionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SessionTypeSingle\000SessionTypeGroup\000";
    static const int32_t values[] = {
        SessionType_SessionTypeSingle,
        SessionType_SessionTypeGroup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SessionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SessionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SessionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SessionType_SessionTypeSingle:
    case SessionType_SessionTypeGroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MsgType

GPBEnumDescriptor *MsgType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MsgTypeSingleText\000MsgTypeSingleAudio\000Msg"
        "TypeGroupText\000MsgTypeGroupAudio\000";
    static const int32_t values[] = {
        MsgType_MsgTypeSingleText,
        MsgType_MsgTypeSingleAudio,
        MsgType_MsgTypeGroupText,
        MsgType_MsgTypeGroupAudio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MsgType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MsgType_MsgTypeSingleText:
    case MsgType_MsgTypeSingleAudio:
    case MsgType_MsgTypeGroupText:
    case MsgType_MsgTypeGroupAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ClientType

GPBEnumDescriptor *ClientType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ClientTypeWindows\000ClientTypeMac\000ClientTy"
        "peIos\000ClientTypeAndroid\000";
    static const int32_t values[] = {
        ClientType_ClientTypeWindows,
        ClientType_ClientTypeMac,
        ClientType_ClientTypeIos,
        ClientType_ClientTypeAndroid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientType_ClientTypeWindows:
    case ClientType_ClientTypeMac:
    case ClientType_ClientTypeIos:
    case ClientType_ClientTypeAndroid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GroupType

GPBEnumDescriptor *GroupType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "GroupTypeNormal\000GroupTypeTmp\000";
    static const int32_t values[] = {
        GroupType_GroupTypeNormal,
        GroupType_GroupTypeTmp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupType_GroupTypeNormal:
    case GroupType_GroupTypeTmp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GroupModifyType

GPBEnumDescriptor *GroupModifyType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "GroupModifyTypeAdd\000GroupModifyTypeDel\000";
    static const int32_t values[] = {
        GroupModifyType_GroupModifyTypeAdd,
        GroupModifyType_GroupModifyTypeDel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupModifyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupModifyType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupModifyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupModifyType_GroupModifyTypeAdd:
    case GroupModifyType_GroupModifyTypeDel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TransferFileType

GPBEnumDescriptor *TransferFileType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FileTypeOnline\000FileTypeOffline\000";
    static const int32_t values[] = {
        TransferFileType_FileTypeOnline,
        TransferFileType_FileTypeOffline,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransferFileType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransferFileType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransferFileType_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransferFileType_FileTypeOnline:
    case TransferFileType_FileTypeOffline:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ClientFileState

GPBEnumDescriptor *ClientFileState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ClientFilePeerReady\000ClientFileCancel\000Cli"
        "entFileRefuse\000ClientFileDone\000";
    static const int32_t values[] = {
        ClientFileState_ClientFilePeerReady,
        ClientFileState_ClientFileCancel,
        ClientFileState_ClientFileRefuse,
        ClientFileState_ClientFileDone,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientFileState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientFileState_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientFileState_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientFileState_ClientFilePeerReady:
    case ClientFileState_ClientFileCancel:
    case ClientFileState_ClientFileRefuse:
    case ClientFileState_ClientFileDone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ClientFileRole

GPBEnumDescriptor *ClientFileRole_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ClientRealtimeSender\000ClientRealtimeRecve"
        "r\000ClientOfflineUpload\000ClientOfflineDownl"
        "oad\000";
    static const int32_t values[] = {
        ClientFileRole_ClientRealtimeSender,
        ClientFileRole_ClientRealtimeRecver,
        ClientFileRole_ClientOfflineUpload,
        ClientFileRole_ClientOfflineDownload,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientFileRole)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientFileRole_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientFileRole_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientFileRole_ClientRealtimeSender:
    case ClientFileRole_ClientRealtimeRecver:
    case ClientFileRole_ClientOfflineUpload:
    case ClientFileRole_ClientOfflineDownload:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileServerError

GPBEnumDescriptor *FileServerError_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FileServerErrnoOk\000FileServerErrnoCreateT"
        "askIdError\000FileServerErrnoCreateTaskErro"
        "r\000FileServerErrnoLoginInvalidToken\000FileS"
        "erverErrnoInvalidUserForTask\000FileServerE"
        "rrnoPullDataWithInvalidTaskId\000FileServer"
        "ErrnoPullDataIllieageUser\000FileServerErrn"
        "oPullDataMkdirError\000FileServerErrnoPullD"
        "ataOpenFileError\000FileServerErrnoPullData"
        "ReadFileHeaderError\000FileServerErrnoPullD"
        "ataAllocMemError\000FileServerErrnoPullData"
        "SeekOffsetError\000FileServerErrnoPullDataF"
        "inished\000";
    static const int32_t values[] = {
        FileServerError_FileServerErrnoOk,
        FileServerError_FileServerErrnoCreateTaskIdError,
        FileServerError_FileServerErrnoCreateTaskError,
        FileServerError_FileServerErrnoLoginInvalidToken,
        FileServerError_FileServerErrnoInvalidUserForTask,
        FileServerError_FileServerErrnoPullDataWithInvalidTaskId,
        FileServerError_FileServerErrnoPullDataIllieageUser,
        FileServerError_FileServerErrnoPullDataMkdirError,
        FileServerError_FileServerErrnoPullDataOpenFileError,
        FileServerError_FileServerErrnoPullDataReadFileHeaderError,
        FileServerError_FileServerErrnoPullDataAllocMemError,
        FileServerError_FileServerErrnoPullDataSeekOffsetError,
        FileServerError_FileServerErrnoPullDataFinished,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileServerError)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileServerError_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileServerError_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileServerError_FileServerErrnoOk:
    case FileServerError_FileServerErrnoCreateTaskIdError:
    case FileServerError_FileServerErrnoCreateTaskError:
    case FileServerError_FileServerErrnoLoginInvalidToken:
    case FileServerError_FileServerErrnoInvalidUserForTask:
    case FileServerError_FileServerErrnoPullDataWithInvalidTaskId:
    case FileServerError_FileServerErrnoPullDataIllieageUser:
    case FileServerError_FileServerErrnoPullDataMkdirError:
    case FileServerError_FileServerErrnoPullDataOpenFileError:
    case FileServerError_FileServerErrnoPullDataReadFileHeaderError:
    case FileServerError_FileServerErrnoPullDataAllocMemError:
    case FileServerError_FileServerErrnoPullDataSeekOffsetError:
    case FileServerError_FileServerErrnoPullDataFinished:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SessionStatusType

GPBEnumDescriptor *SessionStatusType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SessionStatusOk\000SessionStatusDelete\000";
    static const int32_t values[] = {
        SessionStatusType_SessionStatusOk,
        SessionStatusType_SessionStatusDelete,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SessionStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SessionStatusType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SessionStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SessionStatusType_SessionStatusOk:
    case SessionStatusType_SessionStatusDelete:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DepartmentStatusType

GPBEnumDescriptor *DepartmentStatusType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DeptStatusOk\000DeptStatusDelete\000";
    static const int32_t values[] = {
        DepartmentStatusType_DeptStatusOk,
        DepartmentStatusType_DeptStatusDelete,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DepartmentStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DepartmentStatusType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DepartmentStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DepartmentStatusType_DeptStatusOk:
    case DepartmentStatusType_DeptStatusDelete:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - IpAddr

@implementation IpAddr

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct IpAddr__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSString *ip;
} IpAddr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = IpAddr_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IpAddr__storage_, ip),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = IpAddr_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IpAddr__storage_, port),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IpAddr class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IpAddr__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic hasUserId, userId;
@dynamic hasUserGender, userGender;
@dynamic hasUserNickName, userNickName;
@dynamic hasAvatarURL, avatarURL;
@dynamic hasDepartmentId, departmentId;
@dynamic hasEmail, email;
@dynamic hasUserRealName, userRealName;
@dynamic hasUserTel, userTel;
@dynamic hasUserDomain, userDomain;
@dynamic hasStatus, status;
@dynamic hasSignInfo, signInfo;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t userGender;
  uint32_t departmentId;
  uint32_t status;
  NSString *userNickName;
  NSString *avatarURL;
  NSString *email;
  NSString *userRealName;
  NSString *userTel;
  NSString *userDomain;
  NSString *signInfo;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userGender",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UserGender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userGender),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userNickName",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UserNickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userNickName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarURL",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_AvatarURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, avatarURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "departmentId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_DepartmentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfo__storage_, departmentId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Email,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfo__storage_, email),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userRealName",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UserRealName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userRealName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTel",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UserTel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userTel),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UserDomain,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userDomain),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Status,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UserInfo__storage_, status),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signInfo",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_SignInfo,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UserInfo__storage_, signInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContactSessionInfo

@implementation ContactSessionInfo

@dynamic hasSessionId, sessionId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionStatus, sessionStatus;
@dynamic hasUpdatedTime, updatedTime;
@dynamic hasLatestMsgId, latestMsgId;
@dynamic hasLatestMsgData, latestMsgData;
@dynamic hasLatestMsgType, latestMsgType;
@dynamic hasLatestMsgFromUserId, latestMsgFromUserId;

typedef struct ContactSessionInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessionId;
  SessionType sessionType;
  SessionStatusType sessionStatus;
  uint32_t updatedTime;
  uint32_t latestMsgId;
  MsgType latestMsgType;
  uint32_t latestMsgFromUserId;
  NSData *latestMsgData;
} ContactSessionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ContactSessionInfo_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = ContactSessionInfo_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = SessionStatusType_SessionStatusOk,
        .core.name = "sessionStatus",
        .core.dataTypeSpecific.enumDescFunc = SessionStatusType_EnumDescriptor,
        .core.number = ContactSessionInfo_FieldNumber_SessionStatus,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, sessionStatus),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "updatedTime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ContactSessionInfo_FieldNumber_UpdatedTime,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, updatedTime),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "latestMsgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ContactSessionInfo_FieldNumber_LatestMsgId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "latestMsgData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ContactSessionInfo_FieldNumber_LatestMsgData,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgData),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBytes,
      },
      {
        .defaultValue.valueEnum = MsgType_MsgTypeSingleText,
        .core.name = "latestMsgType",
        .core.dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .core.number = ContactSessionInfo_FieldNumber_LatestMsgType,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "latestMsgFromUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ContactSessionInfo_FieldNumber_LatestMsgFromUserId,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ContactSessionInfo__storage_, latestMsgFromUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContactSessionInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ContactSessionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserStat

@implementation UserStat

@dynamic hasUserId, userId;
@dynamic hasStatus, status;

typedef struct UserStat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  UserStatType status;
} UserStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserStat_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(UserStat__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = UserStatType_UserStatusOnline,
        .core.name = "status",
        .core.dataTypeSpecific.enumDescFunc = UserStatType_EnumDescriptor,
        .core.number = UserStat_FieldNumber_Status,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(UserStat__storage_, status),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserStat class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(UserStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerUserStat

@implementation ServerUserStat

@dynamic hasUserId, userId;
@dynamic hasStatus, status;
@dynamic hasClientType, clientType;

typedef struct ServerUserStat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  UserStatType status;
  ClientType clientType;
} ServerUserStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ServerUserStat_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ServerUserStat__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = UserStatType_UserStatusOnline,
        .core.name = "status",
        .core.dataTypeSpecific.enumDescFunc = UserStatType_EnumDescriptor,
        .core.number = ServerUserStat_FieldNumber_Status,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ServerUserStat__storage_, status),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ClientType_ClientTypeWindows,
        .core.name = "clientType",
        .core.dataTypeSpecific.enumDescFunc = ClientType_EnumDescriptor,
        .core.number = ServerUserStat_FieldNumber_ClientType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ServerUserStat__storage_, clientType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerUserStat class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ServerUserStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnreadInfo

@implementation UnreadInfo

@dynamic hasSessionId, sessionId;
@dynamic hasSessionType, sessionType;
@dynamic hasUnreadCnt, unreadCnt;
@dynamic hasLatestMsgId, latestMsgId;
@dynamic hasLatestMsgData, latestMsgData;
@dynamic hasLatestMsgType, latestMsgType;
@dynamic hasLatestMsgFromUserId, latestMsgFromUserId;

typedef struct UnreadInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessionId;
  SessionType sessionType;
  uint32_t unreadCnt;
  uint32_t latestMsgId;
  MsgType latestMsgType;
  uint32_t latestMsgFromUserId;
  NSData *latestMsgData;
} UnreadInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UnreadInfo_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(UnreadInfo__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = UnreadInfo_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(UnreadInfo__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "unreadCnt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UnreadInfo_FieldNumber_UnreadCnt,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(UnreadInfo__storage_, unreadCnt),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "latestMsgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UnreadInfo_FieldNumber_LatestMsgId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "latestMsgData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UnreadInfo_FieldNumber_LatestMsgData,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgData),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBytes,
      },
      {
        .defaultValue.valueEnum = MsgType_MsgTypeSingleText,
        .core.name = "latestMsgType",
        .core.dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .core.number = UnreadInfo_FieldNumber_LatestMsgType,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "latestMsgFromUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UnreadInfo_FieldNumber_LatestMsgFromUserId,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(UnreadInfo__storage_, latestMsgFromUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnreadInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(UnreadInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgInfo

@implementation MsgInfo

@dynamic hasMsgId, msgId;
@dynamic hasFromSessionId, fromSessionId;
@dynamic hasCreateTime, createTime;
@dynamic hasMsgType, msgType;
@dynamic hasMsgData, msgData;

typedef struct MsgInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgId;
  uint32_t fromSessionId;
  uint32_t createTime;
  MsgType msgType;
  NSData *msgData;
} MsgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "msgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MsgInfo_FieldNumber_MsgId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(MsgInfo__storage_, msgId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "fromSessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MsgInfo_FieldNumber_FromSessionId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(MsgInfo__storage_, fromSessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "createTime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MsgInfo_FieldNumber_CreateTime,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(MsgInfo__storage_, createTime),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = MsgType_MsgTypeSingleText,
        .core.name = "msgType",
        .core.dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .core.number = MsgInfo_FieldNumber_MsgType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(MsgInfo__storage_, msgType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "msgData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MsgInfo_FieldNumber_MsgData,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(MsgInfo__storage_, msgData),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(MsgInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupVersionInfo

@implementation GroupVersionInfo

@dynamic hasGroupId, groupId;
@dynamic hasVersion, version;

typedef struct GroupVersionInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t groupId;
  uint32_t version;
} GroupVersionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupVersionInfo_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupVersionInfo__storage_, groupId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = GroupVersionInfo_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupVersionInfo__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupVersionInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupVersionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfo

@implementation GroupInfo

@dynamic hasGroupId, groupId;
@dynamic hasVersion, version;
@dynamic hasGroupName, groupName;
@dynamic hasGroupAvatar, groupAvatar;
@dynamic hasGroupCreatorId, groupCreatorId;
@dynamic hasGroupType, groupType;
@dynamic hasShieldStatus, shieldStatus;
@dynamic groupMemberListArray, groupMemberListArray_Count;

typedef struct GroupInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t groupId;
  uint32_t version;
  uint32_t groupCreatorId;
  GroupType groupType;
  uint32_t shieldStatus;
  NSString *groupName;
  NSString *groupAvatar;
  GPBUInt32Array *groupMemberListArray;
} GroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "groupId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GroupInfo_FieldNumber_GroupId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, groupId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "version",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GroupInfo_FieldNumber_Version,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, version),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "groupName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GroupInfo_FieldNumber_GroupName,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, groupName),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "groupAvatar",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GroupInfo_FieldNumber_GroupAvatar,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, groupAvatar),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "groupCreatorId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GroupInfo_FieldNumber_GroupCreatorId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, groupCreatorId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = GroupType_GroupTypeNormal,
        .core.name = "groupType",
        .core.dataTypeSpecific.enumDescFunc = GroupType_EnumDescriptor,
        .core.number = GroupInfo_FieldNumber_GroupType,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, groupType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "shieldStatus",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GroupInfo_FieldNumber_ShieldStatus,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, shieldStatus),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "groupMemberListArray",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GroupInfo_FieldNumber_GroupMemberListArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(GroupInfo__storage_, groupMemberListArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(GroupInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserTokenInfo

@implementation UserTokenInfo

@dynamic hasUserId, userId;
@dynamic hasUserType, userType;
@dynamic hasToken, token;
@dynamic hasPushCount, pushCount;
@dynamic hasPushType, pushType;

typedef struct UserTokenInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  ClientType userType;
  uint32_t pushCount;
  uint32_t pushType;
  NSString *token;
} UserTokenInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserTokenInfo_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(UserTokenInfo__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = ClientType_ClientTypeWindows,
        .core.name = "userType",
        .core.dataTypeSpecific.enumDescFunc = ClientType_EnumDescriptor,
        .core.number = UserTokenInfo_FieldNumber_UserType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(UserTokenInfo__storage_, userType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "token",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserTokenInfo_FieldNumber_Token,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(UserTokenInfo__storage_, token),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "pushCount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserTokenInfo_FieldNumber_PushCount,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(UserTokenInfo__storage_, pushCount),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "pushType",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserTokenInfo_FieldNumber_PushType,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(UserTokenInfo__storage_, pushType),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserTokenInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(UserTokenInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushResult

@implementation PushResult

@dynamic hasUserToken, userToken;
@dynamic hasResultCode, resultCode;

typedef struct PushResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t resultCode;
  NSString *userToken;
} PushResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userToken",
        .dataTypeSpecific.className = NULL,
        .number = PushResult_FieldNumber_UserToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushResult__storage_, userToken),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resultCode",
        .dataTypeSpecific.className = NULL,
        .number = PushResult_FieldNumber_ResultCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushResult__storage_, resultCode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushResult class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShieldStatus

@implementation ShieldStatus

@dynamic hasUserId, userId;
@dynamic hasGroupId, groupId;
@dynamic hasShieldStatus, shieldStatus;

typedef struct ShieldStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t groupId;
  uint32_t shieldStatus;
} ShieldStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ShieldStatus_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShieldStatus__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = ShieldStatus_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShieldStatus__storage_, groupId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shieldStatus",
        .dataTypeSpecific.className = NULL,
        .number = ShieldStatus_FieldNumber_ShieldStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShieldStatus__storage_, shieldStatus),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShieldStatus class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineFileInfo

@implementation OfflineFileInfo

@dynamic hasFromUserId, fromUserId;
@dynamic hasTaskId, taskId;
@dynamic hasFileName, fileName;
@dynamic hasFileSize, fileSize;

typedef struct OfflineFileInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t fileSize;
  NSString *taskId;
  NSString *fileName;
} OfflineFileInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineFileInfo_FieldNumber_FromUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, fromUserId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineFileInfo_FieldNumber_TaskId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, taskId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = OfflineFileInfo_FieldNumber_FileName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, fileName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = OfflineFileInfo_FieldNumber_FileSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OfflineFileInfo__storage_, fileSize),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineFileInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineFileInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DepartInfo

@implementation DepartInfo

@dynamic hasDeptId, deptId;
@dynamic hasPriority, priority;
@dynamic hasDeptName, deptName;
@dynamic hasParentDeptId, parentDeptId;
@dynamic hasDeptStatus, deptStatus;

typedef struct DepartInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t deptId;
  uint32_t priority;
  uint32_t parentDeptId;
  DepartmentStatusType deptStatus;
  NSString *deptName;
} DepartInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deptId",
        .dataTypeSpecific.className = NULL,
        .number = DepartInfo_FieldNumber_DeptId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, deptId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = DepartInfo_FieldNumber_Priority,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, priority),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deptName",
        .dataTypeSpecific.className = NULL,
        .number = DepartInfo_FieldNumber_DeptName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, deptName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parentDeptId",
        .dataTypeSpecific.className = NULL,
        .number = DepartInfo_FieldNumber_ParentDeptId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, parentDeptId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deptStatus",
        .dataTypeSpecific.enumDescFunc = DepartmentStatusType_EnumDescriptor,
        .number = DepartInfo_FieldNumber_DeptStatus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DepartInfo__storage_, deptStatus),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DepartInfo class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DepartInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushShieldStatus

@implementation PushShieldStatus

@dynamic hasUserId, userId;
@dynamic hasShieldStatus, shieldStatus;

typedef struct PushShieldStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t shieldStatus;
} PushShieldStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PushShieldStatus_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushShieldStatus__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shieldStatus",
        .dataTypeSpecific.className = NULL,
        .number = PushShieldStatus_FieldNumber_ShieldStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushShieldStatus__storage_, shieldStatus),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushShieldStatus class]
                                     rootClass:[ImBaseDefineRoot class]
                                          file:ImBaseDefineRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushShieldStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
