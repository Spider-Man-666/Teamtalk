// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ImBuddy.pbobjc.h"
 #import "ImBaseDefine.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImBuddyRoot

@implementation ImBuddyRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ImBuddyRoot_FileDescriptor

static GPBFileDescriptor *ImBuddyRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.Buddy"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - IMRecentContactSessionReq

@implementation IMRecentContactSessionReq

@dynamic hasUserId, userId;
@dynamic hasLatestUpdateTime, latestUpdateTime;
@dynamic hasAttachData, attachData;

typedef struct IMRecentContactSessionReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t latestUpdateTime;
  NSData *attachData;
} IMRecentContactSessionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMRecentContactSessionReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMRecentContactSessionReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = IMRecentContactSessionReq_FieldNumber_LatestUpdateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMRecentContactSessionReq__storage_, latestUpdateTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMRecentContactSessionReq_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMRecentContactSessionReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRecentContactSessionReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMRecentContactSessionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMRecentContactSessionRsp

@implementation IMRecentContactSessionRsp

@dynamic hasUserId, userId;
@dynamic contactSessionListArray, contactSessionListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMRecentContactSessionRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSMutableArray *contactSessionListArray;
  NSData *attachData;
} IMRecentContactSessionRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMRecentContactSessionRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMRecentContactSessionRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "contactSessionListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ContactSessionInfo),
        .number = IMRecentContactSessionRsp_FieldNumber_ContactSessionListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMRecentContactSessionRsp__storage_, contactSessionListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMRecentContactSessionRsp_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMRecentContactSessionRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRecentContactSessionRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMRecentContactSessionRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUserStatNotify

@implementation IMUserStatNotify

@dynamic hasUserStat, userStat;

typedef struct IMUserStatNotify__storage_ {
  uint32_t _has_storage_[1];
  UserStat *userStat;
} IMUserStatNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userStat",
        .dataTypeSpecific.className = GPBStringifySymbol(UserStat),
        .number = IMUserStatNotify_FieldNumber_UserStat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUserStatNotify__storage_, userStat),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUserStatNotify class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUserStatNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUsersInfoReq

@implementation IMUsersInfoReq

@dynamic hasUserId, userId;
@dynamic userIdListArray, userIdListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMUsersInfoReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  GPBUInt32Array *userIdListArray;
  NSData *attachData;
} IMUsersInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersInfoReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUsersInfoReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userIdListArray",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersInfoReq_FieldNumber_UserIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMUsersInfoReq__storage_, userIdListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersInfoReq_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUsersInfoReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUsersInfoReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUsersInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUsersInfoRsp

@implementation IMUsersInfoRsp

@dynamic hasUserId, userId;
@dynamic userInfoListArray, userInfoListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMUsersInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSMutableArray *userInfoListArray;
  NSData *attachData;
} IMUsersInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersInfoRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUsersInfoRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = IMUsersInfoRsp_FieldNumber_UserInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMUsersInfoRsp__storage_, userInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersInfoRsp_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUsersInfoRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUsersInfoRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUsersInfoRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMRemoveSessionReq

@implementation IMRemoveSessionReq

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic hasAttachData, attachData;

typedef struct IMRemoveSessionReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
  NSData *attachData;
} IMRemoveSessionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionReq_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionReq__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMRemoveSessionReq_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionReq__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionReq_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionReq__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionReq_FieldNumber_AttachData,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionReq__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRemoveSessionReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMRemoveSessionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMRemoveSessionRsp

@implementation IMRemoveSessionRsp

@dynamic hasUserId, userId;
@dynamic hasResultCode, resultCode;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;
@dynamic hasAttachData, attachData;

typedef struct IMRemoveSessionRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t resultCode;
  SessionType sessionType;
  uint32_t sessionId;
  NSData *attachData;
} IMRemoveSessionRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionRsp_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionRsp__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "resultCode",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionRsp_FieldNumber_ResultCode,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionRsp__storage_, resultCode),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMRemoveSessionRsp_FieldNumber_SessionType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionRsp__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionRsp_FieldNumber_SessionId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionRsp__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "attachData",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionRsp_FieldNumber_AttachData,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionRsp__storage_, attachData),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRemoveSessionRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMRemoveSessionRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMAllUserReq

@implementation IMAllUserReq

@dynamic hasUserId, userId;
@dynamic hasLatestUpdateTime, latestUpdateTime;
@dynamic hasAttachData, attachData;

typedef struct IMAllUserReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t latestUpdateTime;
  NSData *attachData;
} IMAllUserReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMAllUserReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMAllUserReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = IMAllUserReq_FieldNumber_LatestUpdateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMAllUserReq__storage_, latestUpdateTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMAllUserReq_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMAllUserReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMAllUserReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMAllUserReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMAllUserRsp

@implementation IMAllUserRsp

@dynamic hasUserId, userId;
@dynamic hasLatestUpdateTime, latestUpdateTime;
@dynamic userListArray, userListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMAllUserRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t latestUpdateTime;
  NSMutableArray *userListArray;
  NSData *attachData;
} IMAllUserRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMAllUserRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMAllUserRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = IMAllUserRsp_FieldNumber_LatestUpdateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMAllUserRsp__storage_, latestUpdateTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = IMAllUserRsp_FieldNumber_UserListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMAllUserRsp__storage_, userListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMAllUserRsp_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMAllUserRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMAllUserRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMAllUserRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUsersStatReq

@implementation IMUsersStatReq

@dynamic hasUserId, userId;
@dynamic userIdListArray, userIdListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMUsersStatReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  GPBUInt32Array *userIdListArray;
  NSData *attachData;
} IMUsersStatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersStatReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUsersStatReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userIdListArray",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersStatReq_FieldNumber_UserIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMUsersStatReq__storage_, userIdListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersStatReq_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUsersStatReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUsersStatReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUsersStatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUsersStatRsp

@implementation IMUsersStatRsp

@dynamic hasUserId, userId;
@dynamic userStatListArray, userStatListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMUsersStatRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSMutableArray *userStatListArray;
  NSData *attachData;
} IMUsersStatRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersStatRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUsersStatRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userStatListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserStat),
        .number = IMUsersStatRsp_FieldNumber_UserStatListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMUsersStatRsp__storage_, userStatListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMUsersStatRsp_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUsersStatRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUsersStatRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUsersStatRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMChangeAvatarReq

@implementation IMChangeAvatarReq

@dynamic hasUserId, userId;
@dynamic hasAvatarURL, avatarURL;
@dynamic hasAttachData, attachData;

typedef struct IMChangeAvatarReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSString *avatarURL;
  NSData *attachData;
} IMChangeAvatarReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeAvatarReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMChangeAvatarReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "avatarURL",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeAvatarReq_FieldNumber_AvatarURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMChangeAvatarReq__storage_, avatarURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeAvatarReq_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMChangeAvatarReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMChangeAvatarReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMChangeAvatarReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMChangeAvatarRsp

@implementation IMChangeAvatarRsp

@dynamic hasUserId, userId;
@dynamic hasResultCode, resultCode;
@dynamic hasAttachData, attachData;

typedef struct IMChangeAvatarRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t resultCode;
  NSData *attachData;
} IMChangeAvatarRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeAvatarRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMChangeAvatarRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "resultCode",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeAvatarRsp_FieldNumber_ResultCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMChangeAvatarRsp__storage_, resultCode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeAvatarRsp_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMChangeAvatarRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMChangeAvatarRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMChangeAvatarRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMPCLoginStatusNotify

@implementation IMPCLoginStatusNotify

@dynamic hasUserId, userId;
@dynamic hasLoginStat, loginStat;

typedef struct IMPCLoginStatusNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  UserStatType loginStat;
} IMPCLoginStatusNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMPCLoginStatusNotify_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMPCLoginStatusNotify__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = UserStatType_UserStatusOnline,
        .core.name = "loginStat",
        .core.dataTypeSpecific.enumDescFunc = UserStatType_EnumDescriptor,
        .core.number = IMPCLoginStatusNotify_FieldNumber_LoginStat,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMPCLoginStatusNotify__storage_, loginStat),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMPCLoginStatusNotify class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMPCLoginStatusNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMRemoveSessionNotify

@implementation IMRemoveSessionNotify

@dynamic hasUserId, userId;
@dynamic hasSessionType, sessionType;
@dynamic hasSessionId, sessionId;

typedef struct IMRemoveSessionNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  SessionType sessionType;
  uint32_t sessionId;
} IMRemoveSessionNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionNotify_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionNotify__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = SessionType_SessionTypeSingle,
        .core.name = "sessionType",
        .core.dataTypeSpecific.enumDescFunc = SessionType_EnumDescriptor,
        .core.number = IMRemoveSessionNotify_FieldNumber_SessionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionNotify__storage_, sessionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMRemoveSessionNotify_FieldNumber_SessionId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMRemoveSessionNotify__storage_, sessionId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRemoveSessionNotify class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMRemoveSessionNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMDepartmentReq

@implementation IMDepartmentReq

@dynamic hasUserId, userId;
@dynamic hasLatestUpdateTime, latestUpdateTime;
@dynamic hasAttachData, attachData;

typedef struct IMDepartmentReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t latestUpdateTime;
  NSData *attachData;
} IMDepartmentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMDepartmentReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMDepartmentReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = IMDepartmentReq_FieldNumber_LatestUpdateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMDepartmentReq__storage_, latestUpdateTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMDepartmentReq_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMDepartmentReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMDepartmentReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMDepartmentReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMDepartmentRsp

@implementation IMDepartmentRsp

@dynamic hasUserId, userId;
@dynamic hasLatestUpdateTime, latestUpdateTime;
@dynamic deptListArray, deptListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMDepartmentRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t latestUpdateTime;
  NSMutableArray *deptListArray;
  NSData *attachData;
} IMDepartmentRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMDepartmentRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMDepartmentRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "latestUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = IMDepartmentRsp_FieldNumber_LatestUpdateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMDepartmentRsp__storage_, latestUpdateTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deptListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DepartInfo),
        .number = IMDepartmentRsp_FieldNumber_DeptListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMDepartmentRsp__storage_, deptListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMDepartmentRsp_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMDepartmentRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMDepartmentRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMDepartmentRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMAvatarChangedNotify

@implementation IMAvatarChangedNotify

@dynamic hasChangedUserId, changedUserId;
@dynamic hasAvatarURL, avatarURL;

typedef struct IMAvatarChangedNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t changedUserId;
  NSString *avatarURL;
} IMAvatarChangedNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "changedUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMAvatarChangedNotify_FieldNumber_ChangedUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMAvatarChangedNotify__storage_, changedUserId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "avatarURL",
        .dataTypeSpecific.className = NULL,
        .number = IMAvatarChangedNotify_FieldNumber_AvatarURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMAvatarChangedNotify__storage_, avatarURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMAvatarChangedNotify class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMAvatarChangedNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMChangeSignInfoReq

@implementation IMChangeSignInfoReq

@dynamic hasUserId, userId;
@dynamic hasSignInfo, signInfo;
@dynamic hasAttachData, attachData;

typedef struct IMChangeSignInfoReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSString *signInfo;
  NSData *attachData;
} IMChangeSignInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeSignInfoReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMChangeSignInfoReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signInfo",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeSignInfoReq_FieldNumber_SignInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMChangeSignInfoReq__storage_, signInfo),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeSignInfoReq_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMChangeSignInfoReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMChangeSignInfoReq class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMChangeSignInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMChangeSignInfoRsp

@implementation IMChangeSignInfoRsp

@dynamic hasUserId, userId;
@dynamic hasResultCode, resultCode;
@dynamic hasSignInfo, signInfo;
@dynamic hasAttachData, attachData;

typedef struct IMChangeSignInfoRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t resultCode;
  NSString *signInfo;
  NSData *attachData;
} IMChangeSignInfoRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeSignInfoRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMChangeSignInfoRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "resultCode",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeSignInfoRsp_FieldNumber_ResultCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMChangeSignInfoRsp__storage_, resultCode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signInfo",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeSignInfoRsp_FieldNumber_SignInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMChangeSignInfoRsp__storage_, signInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMChangeSignInfoRsp_FieldNumber_AttachData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMChangeSignInfoRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMChangeSignInfoRsp class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMChangeSignInfoRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMSignInfoChangedNotify

@implementation IMSignInfoChangedNotify

@dynamic hasChangedUserId, changedUserId;
@dynamic hasSignInfo, signInfo;

typedef struct IMSignInfoChangedNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t changedUserId;
  NSString *signInfo;
} IMSignInfoChangedNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "changedUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMSignInfoChangedNotify_FieldNumber_ChangedUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMSignInfoChangedNotify__storage_, changedUserId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signInfo",
        .dataTypeSpecific.className = NULL,
        .number = IMSignInfoChangedNotify_FieldNumber_SignInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMSignInfoChangedNotify__storage_, signInfo),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMSignInfoChangedNotify class]
                                     rootClass:[ImBuddyRoot class]
                                          file:ImBuddyRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMSignInfoChangedNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
