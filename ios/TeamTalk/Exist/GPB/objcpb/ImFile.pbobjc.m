// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.File.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ImFile.pbobjc.h"
 #import "ImBaseDefine.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImFileRoot

@implementation ImFileRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ImFileRoot_FileDescriptor

static GPBFileDescriptor *ImFileRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.File"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - IMFileLoginReq

@implementation IMFileLoginReq

@dynamic hasUserId, userId;
@dynamic hasTaskId, taskId;
@dynamic hasFileRole, fileRole;

typedef struct IMFileLoginReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  ClientFileRole fileRole;
  NSString *taskId;
} IMFileLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileLoginReq_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMFileLoginReq__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "taskId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileLoginReq_FieldNumber_TaskId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMFileLoginReq__storage_, taskId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ClientFileRole_ClientRealtimeSender,
        .core.name = "fileRole",
        .core.dataTypeSpecific.enumDescFunc = ClientFileRole_EnumDescriptor,
        .core.number = IMFileLoginReq_FieldNumber_FileRole,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMFileLoginReq__storage_, fileRole),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileLoginReq class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMFileLoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileLoginRsp

@implementation IMFileLoginRsp

@dynamic hasResultCode, resultCode;
@dynamic hasTaskId, taskId;

typedef struct IMFileLoginRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t resultCode;
  NSString *taskId;
} IMFileLoginRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultCode",
        .dataTypeSpecific.className = NULL,
        .number = IMFileLoginRsp_FieldNumber_ResultCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileLoginRsp__storage_, resultCode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileLoginRsp_FieldNumber_TaskId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileLoginRsp__storage_, taskId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileLoginRsp class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileLoginRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileState

@implementation IMFileState

@dynamic hasState, state;
@dynamic hasTaskId, taskId;
@dynamic hasUserId, userId;

typedef struct IMFileState__storage_ {
  uint32_t _has_storage_[1];
  ClientFileState state;
  uint32_t userId;
  NSString *taskId;
} IMFileState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = ClientFileState_EnumDescriptor,
        .number = IMFileState_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileState__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileState_FieldNumber_TaskId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileState__storage_, taskId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileState_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMFileState__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileState class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFilePullDataReq

@implementation IMFilePullDataReq

@dynamic hasTaskId, taskId;
@dynamic hasUserId, userId;
@dynamic hasTransMode, transMode;
@dynamic hasOffset, offset;
@dynamic hasDataSize, dataSize;

typedef struct IMFilePullDataReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  TransferFileType transMode;
  uint32_t offset;
  uint32_t dataSize;
  NSString *taskId;
} IMFilePullDataReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "taskId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFilePullDataReq_FieldNumber_TaskId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMFilePullDataReq__storage_, taskId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFilePullDataReq_FieldNumber_UserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMFilePullDataReq__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = TransferFileType_FileTypeOnline,
        .core.name = "transMode",
        .core.dataTypeSpecific.enumDescFunc = TransferFileType_EnumDescriptor,
        .core.number = IMFilePullDataReq_FieldNumber_TransMode,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMFilePullDataReq__storage_, transMode),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "offset",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFilePullDataReq_FieldNumber_Offset,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMFilePullDataReq__storage_, offset),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "dataSize",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFilePullDataReq_FieldNumber_DataSize,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMFilePullDataReq__storage_, dataSize),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFilePullDataReq class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMFilePullDataReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFilePullDataRsp

@implementation IMFilePullDataRsp

@dynamic hasResultCode, resultCode;
@dynamic hasTaskId, taskId;
@dynamic hasUserId, userId;
@dynamic hasOffset, offset;
@dynamic hasFileData, fileData;

typedef struct IMFilePullDataRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t resultCode;
  uint32_t userId;
  uint32_t offset;
  NSString *taskId;
  NSData *fileData;
} IMFilePullDataRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultCode",
        .dataTypeSpecific.className = NULL,
        .number = IMFilePullDataRsp_FieldNumber_ResultCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFilePullDataRsp__storage_, resultCode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.className = NULL,
        .number = IMFilePullDataRsp_FieldNumber_TaskId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFilePullDataRsp__storage_, taskId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMFilePullDataRsp_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMFilePullDataRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = IMFilePullDataRsp_FieldNumber_Offset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMFilePullDataRsp__storage_, offset),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileData",
        .dataTypeSpecific.className = NULL,
        .number = IMFilePullDataRsp_FieldNumber_FileData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMFilePullDataRsp__storage_, fileData),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFilePullDataRsp class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFilePullDataRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileReq

@implementation IMFileReq

@dynamic hasFromUserId, fromUserId;
@dynamic hasToUserId, toUserId;
@dynamic hasFileName, fileName;
@dynamic hasFileSize, fileSize;
@dynamic hasTransMode, transMode;

typedef struct IMFileReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t toUserId;
  uint32_t fileSize;
  TransferFileType transMode;
  NSString *fileName;
} IMFileReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "fromUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileReq_FieldNumber_FromUserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMFileReq__storage_, fromUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "toUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileReq_FieldNumber_ToUserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMFileReq__storage_, toUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "fileName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileReq_FieldNumber_FileName,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMFileReq__storage_, fileName),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "fileSize",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileReq_FieldNumber_FileSize,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMFileReq__storage_, fileSize),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = TransferFileType_FileTypeOnline,
        .core.name = "transMode",
        .core.dataTypeSpecific.enumDescFunc = TransferFileType_EnumDescriptor,
        .core.number = IMFileReq_FieldNumber_TransMode,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMFileReq__storage_, transMode),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileReq class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMFileReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileRsp

@implementation IMFileRsp

@dynamic hasResultCode, resultCode;
@dynamic hasFromUserId, fromUserId;
@dynamic hasToUserId, toUserId;
@dynamic hasFileName, fileName;
@dynamic hasTaskId, taskId;
@dynamic ipAddrListArray, ipAddrListArray_Count;
@dynamic hasTransMode, transMode;

typedef struct IMFileRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t resultCode;
  uint32_t fromUserId;
  uint32_t toUserId;
  TransferFileType transMode;
  NSString *fileName;
  NSString *taskId;
  NSMutableArray *ipAddrListArray;
} IMFileRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "resultCode",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileRsp_FieldNumber_ResultCode,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMFileRsp__storage_, resultCode),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "fromUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileRsp_FieldNumber_FromUserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMFileRsp__storage_, fromUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "toUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileRsp_FieldNumber_ToUserId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMFileRsp__storage_, toUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "fileName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileRsp_FieldNumber_FileName,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMFileRsp__storage_, fileName),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "taskId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileRsp_FieldNumber_TaskId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMFileRsp__storage_, taskId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "ipAddrListArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(IpAddr),
        .core.number = IMFileRsp_FieldNumber_IpAddrListArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(IMFileRsp__storage_, ipAddrListArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = TransferFileType_FileTypeOnline,
        .core.name = "transMode",
        .core.dataTypeSpecific.enumDescFunc = TransferFileType_EnumDescriptor,
        .core.number = IMFileRsp_FieldNumber_TransMode,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(IMFileRsp__storage_, transMode),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileRsp class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMFileRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileNotify

@implementation IMFileNotify

@dynamic hasFromUserId, fromUserId;
@dynamic hasToUserId, toUserId;
@dynamic hasFileName, fileName;
@dynamic hasFileSize, fileSize;
@dynamic hasTaskId, taskId;
@dynamic ipAddrListArray, ipAddrListArray_Count;
@dynamic hasTransMode, transMode;
@dynamic hasOfflineReady, offlineReady;

typedef struct IMFileNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t toUserId;
  uint32_t fileSize;
  TransferFileType transMode;
  uint32_t offlineReady;
  NSString *fileName;
  NSString *taskId;
  NSMutableArray *ipAddrListArray;
} IMFileNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "fromUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileNotify_FieldNumber_FromUserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, fromUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "toUserId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileNotify_FieldNumber_ToUserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, toUserId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "fileName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileNotify_FieldNumber_FileName,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, fileName),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "fileSize",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileNotify_FieldNumber_FileSize,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, fileSize),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "taskId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileNotify_FieldNumber_TaskId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, taskId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "ipAddrListArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(IpAddr),
        .core.number = IMFileNotify_FieldNumber_IpAddrListArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, ipAddrListArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = TransferFileType_FileTypeOnline,
        .core.name = "transMode",
        .core.dataTypeSpecific.enumDescFunc = TransferFileType_EnumDescriptor,
        .core.number = IMFileNotify_FieldNumber_TransMode,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, transMode),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "offlineReady",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMFileNotify_FieldNumber_OfflineReady,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(IMFileNotify__storage_, offlineReady),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileNotify class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMFileNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileHasOfflineReq

@implementation IMFileHasOfflineReq

@dynamic hasUserId, userId;
@dynamic hasAttachData, attachData;

typedef struct IMFileHasOfflineReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSData *attachData;
} IMFileHasOfflineReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileHasOfflineReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileHasOfflineReq__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMFileHasOfflineReq_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileHasOfflineReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileHasOfflineReq class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileHasOfflineReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileHasOfflineRsp

@implementation IMFileHasOfflineRsp

@dynamic hasUserId, userId;
@dynamic offlineFileListArray, offlineFileListArray_Count;
@dynamic ipAddrListArray, ipAddrListArray_Count;
@dynamic hasAttachData, attachData;

typedef struct IMFileHasOfflineRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  NSMutableArray *offlineFileListArray;
  NSMutableArray *ipAddrListArray;
  NSData *attachData;
} IMFileHasOfflineRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileHasOfflineRsp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileHasOfflineRsp__storage_, userId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "offlineFileListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OfflineFileInfo),
        .number = IMFileHasOfflineRsp_FieldNumber_OfflineFileListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMFileHasOfflineRsp__storage_, offlineFileListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ipAddrListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(IpAddr),
        .number = IMFileHasOfflineRsp_FieldNumber_IpAddrListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMFileHasOfflineRsp__storage_, ipAddrListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMFileHasOfflineRsp_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileHasOfflineRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileHasOfflineRsp class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileHasOfflineRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileAddOfflineReq

@implementation IMFileAddOfflineReq

@dynamic hasFromUserId, fromUserId;
@dynamic hasToUserId, toUserId;
@dynamic hasTaskId, taskId;
@dynamic hasFileName, fileName;
@dynamic hasFileSize, fileSize;

typedef struct IMFileAddOfflineReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t toUserId;
  uint32_t fileSize;
  NSString *taskId;
  NSString *fileName;
} IMFileAddOfflineReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileAddOfflineReq_FieldNumber_FromUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileAddOfflineReq__storage_, fromUserId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileAddOfflineReq_FieldNumber_ToUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileAddOfflineReq__storage_, toUserId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileAddOfflineReq_FieldNumber_TaskId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMFileAddOfflineReq__storage_, taskId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = IMFileAddOfflineReq_FieldNumber_FileName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMFileAddOfflineReq__storage_, fileName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = IMFileAddOfflineReq_FieldNumber_FileSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMFileAddOfflineReq__storage_, fileSize),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileAddOfflineReq class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileAddOfflineReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileDelOfflineReq

@implementation IMFileDelOfflineReq

@dynamic hasFromUserId, fromUserId;
@dynamic hasToUserId, toUserId;
@dynamic hasTaskId, taskId;

typedef struct IMFileDelOfflineReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t toUserId;
  NSString *taskId;
} IMFileDelOfflineReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileDelOfflineReq_FieldNumber_FromUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileDelOfflineReq__storage_, fromUserId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileDelOfflineReq_FieldNumber_ToUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileDelOfflineReq__storage_, toUserId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileDelOfflineReq_FieldNumber_TaskId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMFileDelOfflineReq__storage_, taskId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileDelOfflineReq class]
                                     rootClass:[ImFileRoot class]
                                          file:ImFileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileDelOfflineReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
