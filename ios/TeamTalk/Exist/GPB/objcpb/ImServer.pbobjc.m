// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Server.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ImServer.pbobjc.h"
 #import "ImBaseDefine.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImServerRoot

@implementation ImServerRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ImServerRoot_FileDescriptor

static GPBFileDescriptor *ImServerRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.Server"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - IMStopReceivePacket

@implementation IMStopReceivePacket

@dynamic result;

typedef struct IMStopReceivePacket__storage_ {
  uint32_t _has_storage_[1];
  uint32_t result;
} IMStopReceivePacket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = IMStopReceivePacket_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMStopReceivePacket__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMStopReceivePacket class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMStopReceivePacket__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMValidateReq

@implementation IMValidateReq

@dynamic userName;
@dynamic password;
@dynamic attachData;

typedef struct IMValidateReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
  NSString *password;
  NSData *attachData;
} IMValidateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = IMValidateReq_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMValidateReq__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = IMValidateReq_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMValidateReq__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMValidateReq_FieldNumber_AttachData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMValidateReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMValidateReq class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMValidateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMValidateRsp

@implementation IMValidateRsp

@dynamic userName;
@dynamic resultCode;
@dynamic resultString;
@dynamic hasUserInfo, userInfo;
@dynamic attachData;

typedef struct IMValidateRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t resultCode;
  NSString *userName;
  NSString *resultString;
  UserInfo *userInfo;
  NSData *attachData;
} IMValidateRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = IMValidateRsp_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMValidateRsp__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resultCode",
        .dataTypeSpecific.className = NULL,
        .number = IMValidateRsp_FieldNumber_ResultCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMValidateRsp__storage_, resultCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "resultString",
        .dataTypeSpecific.className = NULL,
        .number = IMValidateRsp_FieldNumber_ResultString,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMValidateRsp__storage_, resultString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = IMValidateRsp_FieldNumber_UserInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMValidateRsp__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMValidateRsp_FieldNumber_AttachData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMValidateRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMValidateRsp class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMValidateRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetDeviceTokenReq

@implementation IMGetDeviceTokenReq

@dynamic userIdArray, userIdArray_Count;
@dynamic attachData;

typedef struct IMGetDeviceTokenReq__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *userIdArray;
  NSData *attachData;
} IMGetDeviceTokenReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdArray",
        .dataTypeSpecific.className = NULL,
        .number = IMGetDeviceTokenReq_FieldNumber_UserIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMGetDeviceTokenReq__storage_, userIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetDeviceTokenReq_FieldNumber_AttachData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetDeviceTokenReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetDeviceTokenReq class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetDeviceTokenReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGetDeviceTokenRsp

@implementation IMGetDeviceTokenRsp

@dynamic userTokenInfoArray, userTokenInfoArray_Count;
@dynamic attachData;

typedef struct IMGetDeviceTokenRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userTokenInfoArray;
  NSData *attachData;
} IMGetDeviceTokenRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userTokenInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserTokenInfo),
        .number = IMGetDeviceTokenRsp_FieldNumber_UserTokenInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMGetDeviceTokenRsp__storage_, userTokenInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGetDeviceTokenRsp_FieldNumber_AttachData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGetDeviceTokenRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGetDeviceTokenRsp class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGetDeviceTokenRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMRoleSet

@implementation IMRoleSet

@dynamic master;

typedef struct IMRoleSet__storage_ {
  uint32_t _has_storage_[1];
  uint32_t master;
} IMRoleSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "master",
        .dataTypeSpecific.className = NULL,
        .number = IMRoleSet_FieldNumber_Master,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMRoleSet__storage_, master),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRoleSet class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMRoleSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMOnlineUserInfo

@implementation IMOnlineUserInfo

@dynamic userStatListArray, userStatListArray_Count;

typedef struct IMOnlineUserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userStatListArray;
} IMOnlineUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userStatListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ServerUserStat),
        .number = IMOnlineUserInfo_FieldNumber_UserStatListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMOnlineUserInfo__storage_, userStatListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMOnlineUserInfo class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMOnlineUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMsgServInfo

@implementation IMMsgServInfo

@dynamic ip1;
@dynamic ip2;
@dynamic port;
@dynamic maxConnCnt;
@dynamic curConnCnt;
@dynamic hostName;

typedef struct IMMsgServInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  uint32_t maxConnCnt;
  uint32_t curConnCnt;
  NSString *ip1;
  NSString *ip2;
  NSString *hostName;
} IMMsgServInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip1",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgServInfo_FieldNumber_Ip1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMsgServInfo__storage_, ip1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ip2",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgServInfo_FieldNumber_Ip2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMsgServInfo__storage_, ip2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgServInfo_FieldNumber_Port,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMMsgServInfo__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxConnCnt",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgServInfo_FieldNumber_MaxConnCnt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMMsgServInfo__storage_, maxConnCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "curConnCnt",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgServInfo_FieldNumber_CurConnCnt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMMsgServInfo__storage_, curConnCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = IMMsgServInfo_FieldNumber_HostName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IMMsgServInfo__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMsgServInfo class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMsgServInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMUserStatusUpdate

@implementation IMUserStatusUpdate

@dynamic userStatus;
@dynamic userId;
@dynamic clientType;

typedef struct IMUserStatusUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userStatus;
  uint32_t userId;
  ClientType clientType;
} IMUserStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userStatus",
        .dataTypeSpecific.className = NULL,
        .number = IMUserStatusUpdate_FieldNumber_UserStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUserStatusUpdate__storage_, userStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUserStatusUpdate_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUserStatusUpdate__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientType",
        .dataTypeSpecific.enumDescFunc = ClientType_EnumDescriptor,
        .number = IMUserStatusUpdate_FieldNumber_ClientType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMUserStatusUpdate__storage_, clientType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUserStatusUpdate class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUserStatusUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMUserStatusUpdate_ClientType_RawValue(IMUserStatusUpdate *message) {
  GPBDescriptor *descriptor = [IMUserStatusUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMUserStatusUpdate_FieldNumber_ClientType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMUserStatusUpdate_ClientType_RawValue(IMUserStatusUpdate *message, int32_t value) {
  GPBDescriptor *descriptor = [IMUserStatusUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMUserStatusUpdate_FieldNumber_ClientType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMUserCntUpdate

@implementation IMUserCntUpdate

@dynamic userAction;
@dynamic userId;

typedef struct IMUserCntUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userAction;
  uint32_t userId;
} IMUserCntUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userAction",
        .dataTypeSpecific.className = NULL,
        .number = IMUserCntUpdate_FieldNumber_UserAction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMUserCntUpdate__storage_, userAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMUserCntUpdate_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMUserCntUpdate__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMUserCntUpdate class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMUserCntUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMServerKickUser

@implementation IMServerKickUser

@dynamic userId;
@dynamic clientType;
@dynamic reason;

typedef struct IMServerKickUser__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  ClientType clientType;
  uint32_t reason;
} IMServerKickUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMServerKickUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMServerKickUser__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientType",
        .dataTypeSpecific.enumDescFunc = ClientType_EnumDescriptor,
        .number = IMServerKickUser_FieldNumber_ClientType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMServerKickUser__storage_, clientType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = IMServerKickUser_FieldNumber_Reason,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMServerKickUser__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMServerKickUser class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMServerKickUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMServerKickUser_ClientType_RawValue(IMServerKickUser *message) {
  GPBDescriptor *descriptor = [IMServerKickUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMServerKickUser_FieldNumber_ClientType];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMServerKickUser_ClientType_RawValue(IMServerKickUser *message, int32_t value) {
  GPBDescriptor *descriptor = [IMServerKickUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMServerKickUser_FieldNumber_ClientType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMServerPCLoginStatusNotify

@implementation IMServerPCLoginStatusNotify

@dynamic userId;
@dynamic loginStatus;

typedef struct IMServerPCLoginStatusNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t userId;
  uint32_t loginStatus;
} IMServerPCLoginStatusNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = IMServerPCLoginStatusNotify_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMServerPCLoginStatusNotify__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "loginStatus",
        .dataTypeSpecific.className = NULL,
        .number = IMServerPCLoginStatusNotify_FieldNumber_LoginStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMServerPCLoginStatusNotify__storage_, loginStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMServerPCLoginStatusNotify class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMServerPCLoginStatusNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMPushToUserReq

@implementation IMPushToUserReq

@dynamic flash;
@dynamic data_p;
@dynamic userTokenListArray, userTokenListArray_Count;

typedef struct IMPushToUserReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *flash;
  NSString *data_p;
  NSMutableArray *userTokenListArray;
} IMPushToUserReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flash",
        .dataTypeSpecific.className = NULL,
        .number = IMPushToUserReq_FieldNumber_Flash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMPushToUserReq__storage_, flash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = IMPushToUserReq_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMPushToUserReq__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTokenListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserTokenInfo),
        .number = IMPushToUserReq_FieldNumber_UserTokenListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMPushToUserReq__storage_, userTokenListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMPushToUserReq class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMPushToUserReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMPushToUserRsp

@implementation IMPushToUserRsp

@dynamic pushResultListArray, pushResultListArray_Count;

typedef struct IMPushToUserRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pushResultListArray;
} IMPushToUserRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pushResultListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PushResult),
        .number = IMPushToUserRsp_FieldNumber_PushResultListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMPushToUserRsp__storage_, pushResultListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMPushToUserRsp class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMPushToUserRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGroupGetShieldReq

@implementation IMGroupGetShieldReq

@dynamic groupId;
@dynamic userIdArray, userIdArray_Count;
@dynamic attachData;

typedef struct IMGroupGetShieldReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t groupId;
  GPBUInt32Array *userIdArray;
  NSData *attachData;
} IMGroupGetShieldReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = IMGroupGetShieldReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGroupGetShieldReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userIdArray",
        .dataTypeSpecific.className = NULL,
        .number = IMGroupGetShieldReq_FieldNumber_UserIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMGroupGetShieldReq__storage_, userIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGroupGetShieldReq_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGroupGetShieldReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGroupGetShieldReq class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGroupGetShieldReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMGroupGetShieldRsp

@implementation IMGroupGetShieldRsp

@dynamic groupId;
@dynamic shieldStatusListArray, shieldStatusListArray_Count;
@dynamic attachData;

typedef struct IMGroupGetShieldRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t groupId;
  NSMutableArray *shieldStatusListArray;
  NSData *attachData;
} IMGroupGetShieldRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = IMGroupGetShieldRsp_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMGroupGetShieldRsp__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shieldStatusListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ShieldStatus),
        .number = IMGroupGetShieldRsp_FieldNumber_ShieldStatusListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMGroupGetShieldRsp__storage_, shieldStatusListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMGroupGetShieldRsp_FieldNumber_AttachData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMGroupGetShieldRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMGroupGetShieldRsp class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMGroupGetShieldRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileTransferReq

@implementation IMFileTransferReq

@dynamic fromUserId;
@dynamic toUserId;
@dynamic fileName;
@dynamic fileSize;
@dynamic transMode;
@dynamic attachData;

typedef struct IMFileTransferReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUserId;
  uint32_t toUserId;
  uint32_t fileSize;
  TransferFileType transMode;
  NSString *fileName;
  NSData *attachData;
} IMFileTransferReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferReq_FieldNumber_FromUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileTransferReq__storage_, fromUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferReq_FieldNumber_ToUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileTransferReq__storage_, toUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferReq_FieldNumber_FileName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMFileTransferReq__storage_, fileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferReq_FieldNumber_FileSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMFileTransferReq__storage_, fileSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "transMode",
        .dataTypeSpecific.enumDescFunc = TransferFileType_EnumDescriptor,
        .number = IMFileTransferReq_FieldNumber_TransMode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMFileTransferReq__storage_, transMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferReq_FieldNumber_AttachData,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IMFileTransferReq__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileTransferReq class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileTransferReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMFileTransferReq_TransMode_RawValue(IMFileTransferReq *message) {
  GPBDescriptor *descriptor = [IMFileTransferReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMFileTransferReq_FieldNumber_TransMode];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMFileTransferReq_TransMode_RawValue(IMFileTransferReq *message, int32_t value) {
  GPBDescriptor *descriptor = [IMFileTransferReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMFileTransferReq_FieldNumber_TransMode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMFileTransferRsp

@implementation IMFileTransferRsp

@dynamic resultCode;
@dynamic fromUserId;
@dynamic toUserId;
@dynamic fileName;
@dynamic fileSize;
@dynamic taskId;
@dynamic transMode;
@dynamic attachData;

typedef struct IMFileTransferRsp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t resultCode;
  uint32_t fromUserId;
  uint32_t toUserId;
  uint32_t fileSize;
  TransferFileType transMode;
  NSString *fileName;
  NSString *taskId;
  NSData *attachData;
} IMFileTransferRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultCode",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferRsp_FieldNumber_ResultCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, resultCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fromUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferRsp_FieldNumber_FromUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, fromUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferRsp_FieldNumber_ToUserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, toUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferRsp_FieldNumber_FileName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, fileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferRsp_FieldNumber_FileSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, fileSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferRsp_FieldNumber_TaskId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, taskId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transMode",
        .dataTypeSpecific.enumDescFunc = TransferFileType_EnumDescriptor,
        .number = IMFileTransferRsp_FieldNumber_TransMode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, transMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "attachData",
        .dataTypeSpecific.className = NULL,
        .number = IMFileTransferRsp_FieldNumber_AttachData,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(IMFileTransferRsp__storage_, attachData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileTransferRsp class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileTransferRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t IMFileTransferRsp_TransMode_RawValue(IMFileTransferRsp *message) {
  GPBDescriptor *descriptor = [IMFileTransferRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMFileTransferRsp_FieldNumber_TransMode];
  return GPBGetMessageInt32Field(message, field);
}

void SetIMFileTransferRsp_TransMode_RawValue(IMFileTransferRsp *message, int32_t value) {
  GPBDescriptor *descriptor = [IMFileTransferRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:IMFileTransferRsp_FieldNumber_TransMode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - IMFileServerIPReq

@implementation IMFileServerIPReq


typedef struct IMFileServerIPReq__storage_ {
  uint32_t _has_storage_[1];
} IMFileServerIPReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileServerIPReq class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(IMFileServerIPReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMFileServerIPRsp

@implementation IMFileServerIPRsp

@dynamic ipAddrListArray, ipAddrListArray_Count;

typedef struct IMFileServerIPRsp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *ipAddrListArray;
} IMFileServerIPRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ipAddrListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(IpAddr),
        .number = IMFileServerIPRsp_FieldNumber_IpAddrListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IMFileServerIPRsp__storage_, ipAddrListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMFileServerIPRsp class]
                                     rootClass:[ImServerRoot class]
                                          file:ImServerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMFileServerIPRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
