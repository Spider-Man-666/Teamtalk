// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.File.proto

#ifndef PROTOBUF_IM_2eFile_2eproto__INCLUDED
#define PROTOBUF_IM_2eFile_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_IM_2eFile_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsIMFileLoginReqImpl();
void InitDefaultsIMFileLoginReq();
void InitDefaultsIMFileLoginRspImpl();
void InitDefaultsIMFileLoginRsp();
void InitDefaultsIMFileStateImpl();
void InitDefaultsIMFileState();
void InitDefaultsIMFilePullDataReqImpl();
void InitDefaultsIMFilePullDataReq();
void InitDefaultsIMFilePullDataRspImpl();
void InitDefaultsIMFilePullDataRsp();
void InitDefaultsIMFileReqImpl();
void InitDefaultsIMFileReq();
void InitDefaultsIMFileRspImpl();
void InitDefaultsIMFileRsp();
void InitDefaultsIMFileNotifyImpl();
void InitDefaultsIMFileNotify();
void InitDefaultsIMFileHasOfflineReqImpl();
void InitDefaultsIMFileHasOfflineReq();
void InitDefaultsIMFileHasOfflineRspImpl();
void InitDefaultsIMFileHasOfflineRsp();
void InitDefaultsIMFileAddOfflineReqImpl();
void InitDefaultsIMFileAddOfflineReq();
void InitDefaultsIMFileDelOfflineReqImpl();
void InitDefaultsIMFileDelOfflineReq();
inline void InitDefaults() {
  InitDefaultsIMFileLoginReq();
  InitDefaultsIMFileLoginRsp();
  InitDefaultsIMFileState();
  InitDefaultsIMFilePullDataReq();
  InitDefaultsIMFilePullDataRsp();
  InitDefaultsIMFileReq();
  InitDefaultsIMFileRsp();
  InitDefaultsIMFileNotify();
  InitDefaultsIMFileHasOfflineReq();
  InitDefaultsIMFileHasOfflineRsp();
  InitDefaultsIMFileAddOfflineReq();
  InitDefaultsIMFileDelOfflineReq();
}
}  // namespace protobuf_IM_2eFile_2eproto
namespace IM {
namespace File {
class IMFileAddOfflineReq;
class IMFileAddOfflineReqDefaultTypeInternal;
extern IMFileAddOfflineReqDefaultTypeInternal _IMFileAddOfflineReq_default_instance_;
class IMFileDelOfflineReq;
class IMFileDelOfflineReqDefaultTypeInternal;
extern IMFileDelOfflineReqDefaultTypeInternal _IMFileDelOfflineReq_default_instance_;
class IMFileHasOfflineReq;
class IMFileHasOfflineReqDefaultTypeInternal;
extern IMFileHasOfflineReqDefaultTypeInternal _IMFileHasOfflineReq_default_instance_;
class IMFileHasOfflineRsp;
class IMFileHasOfflineRspDefaultTypeInternal;
extern IMFileHasOfflineRspDefaultTypeInternal _IMFileHasOfflineRsp_default_instance_;
class IMFileLoginReq;
class IMFileLoginReqDefaultTypeInternal;
extern IMFileLoginReqDefaultTypeInternal _IMFileLoginReq_default_instance_;
class IMFileLoginRsp;
class IMFileLoginRspDefaultTypeInternal;
extern IMFileLoginRspDefaultTypeInternal _IMFileLoginRsp_default_instance_;
class IMFileNotify;
class IMFileNotifyDefaultTypeInternal;
extern IMFileNotifyDefaultTypeInternal _IMFileNotify_default_instance_;
class IMFilePullDataReq;
class IMFilePullDataReqDefaultTypeInternal;
extern IMFilePullDataReqDefaultTypeInternal _IMFilePullDataReq_default_instance_;
class IMFilePullDataRsp;
class IMFilePullDataRspDefaultTypeInternal;
extern IMFilePullDataRspDefaultTypeInternal _IMFilePullDataRsp_default_instance_;
class IMFileReq;
class IMFileReqDefaultTypeInternal;
extern IMFileReqDefaultTypeInternal _IMFileReq_default_instance_;
class IMFileRsp;
class IMFileRspDefaultTypeInternal;
extern IMFileRspDefaultTypeInternal _IMFileRsp_default_instance_;
class IMFileState;
class IMFileStateDefaultTypeInternal;
extern IMFileStateDefaultTypeInternal _IMFileState_default_instance_;
}  // namespace File
}  // namespace IM
namespace IM {
namespace File {

// ===================================================================

class IMFileLoginReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginReq) */ {
 public:
  IMFileLoginReq();
  virtual ~IMFileLoginReq();

  IMFileLoginReq(const IMFileLoginReq& from);

  inline IMFileLoginReq& operator=(const IMFileLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileLoginReq(IMFileLoginReq&& from) noexcept
    : IMFileLoginReq() {
    *this = ::std::move(from);
  }

  inline IMFileLoginReq& operator=(IMFileLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileLoginReq* internal_default_instance() {
    return reinterpret_cast<const IMFileLoginReq*>(
               &_IMFileLoginReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(IMFileLoginReq* other);
  friend void swap(IMFileLoginReq& a, IMFileLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileLoginReq* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileLoginReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileLoginReq& from);
  void MergeFrom(const IMFileLoginReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // uint32 user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // .IM.BaseDefine.ClientFileRole file_role = 3;
  void clear_file_role();
  static const int kFileRoleFieldNumber = 3;
  ::IM::BaseDefine::ClientFileRole file_role() const;
  void set_file_role(::IM::BaseDefine::ClientFileRole value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 user_id_;
  int file_role_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileLoginReqImpl();
};
// -------------------------------------------------------------------

class IMFileLoginRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginRsp) */ {
 public:
  IMFileLoginRsp();
  virtual ~IMFileLoginRsp();

  IMFileLoginRsp(const IMFileLoginRsp& from);

  inline IMFileLoginRsp& operator=(const IMFileLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileLoginRsp(IMFileLoginRsp&& from) noexcept
    : IMFileLoginRsp() {
    *this = ::std::move(from);
  }

  inline IMFileLoginRsp& operator=(IMFileLoginRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileLoginRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileLoginRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileLoginRsp*>(
               &_IMFileLoginRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(IMFileLoginRsp* other);
  friend void swap(IMFileLoginRsp& a, IMFileLoginRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileLoginRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileLoginRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileLoginRsp& from);
  void MergeFrom(const IMFileLoginRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileLoginRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // uint32 result_code = 1;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 result_code_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileLoginRspImpl();
};
// -------------------------------------------------------------------

class IMFileState : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileState) */ {
 public:
  IMFileState();
  virtual ~IMFileState();

  IMFileState(const IMFileState& from);

  inline IMFileState& operator=(const IMFileState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileState(IMFileState&& from) noexcept
    : IMFileState() {
    *this = ::std::move(from);
  }

  inline IMFileState& operator=(IMFileState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileState* internal_default_instance() {
    return reinterpret_cast<const IMFileState*>(
               &_IMFileState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(IMFileState* other);
  friend void swap(IMFileState& a, IMFileState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileState* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileState& from);
  void MergeFrom(const IMFileState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // .IM.BaseDefine.ClientFileState state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::IM::BaseDefine::ClientFileState state() const;
  void set_state(::IM::BaseDefine::ClientFileState value);

  // uint32 user_id = 3;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  int state_;
  ::google::protobuf::uint32 user_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileStateImpl();
};
// -------------------------------------------------------------------

class IMFilePullDataReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataReq) */ {
 public:
  IMFilePullDataReq();
  virtual ~IMFilePullDataReq();

  IMFilePullDataReq(const IMFilePullDataReq& from);

  inline IMFilePullDataReq& operator=(const IMFilePullDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFilePullDataReq(IMFilePullDataReq&& from) noexcept
    : IMFilePullDataReq() {
    *this = ::std::move(from);
  }

  inline IMFilePullDataReq& operator=(IMFilePullDataReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFilePullDataReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFilePullDataReq* internal_default_instance() {
    return reinterpret_cast<const IMFilePullDataReq*>(
               &_IMFilePullDataReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(IMFilePullDataReq* other);
  friend void swap(IMFilePullDataReq& a, IMFilePullDataReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFilePullDataReq* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFilePullDataReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFilePullDataReq& from);
  void MergeFrom(const IMFilePullDataReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFilePullDataReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 1;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // uint32 user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // .IM.BaseDefine.TransferFileType trans_mode = 3;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 3;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // uint32 offset = 4;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // uint32 data_size = 5;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 5;
  ::google::protobuf::uint32 data_size() const;
  void set_data_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 user_id_;
  int trans_mode_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 data_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFilePullDataReqImpl();
};
// -------------------------------------------------------------------

class IMFilePullDataRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataRsp) */ {
 public:
  IMFilePullDataRsp();
  virtual ~IMFilePullDataRsp();

  IMFilePullDataRsp(const IMFilePullDataRsp& from);

  inline IMFilePullDataRsp& operator=(const IMFilePullDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFilePullDataRsp(IMFilePullDataRsp&& from) noexcept
    : IMFilePullDataRsp() {
    *this = ::std::move(from);
  }

  inline IMFilePullDataRsp& operator=(IMFilePullDataRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFilePullDataRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFilePullDataRsp* internal_default_instance() {
    return reinterpret_cast<const IMFilePullDataRsp*>(
               &_IMFilePullDataRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(IMFilePullDataRsp* other);
  friend void swap(IMFilePullDataRsp& a, IMFilePullDataRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFilePullDataRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFilePullDataRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFilePullDataRsp& from);
  void MergeFrom(const IMFilePullDataRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFilePullDataRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // bytes file_data = 5;
  void clear_file_data();
  static const int kFileDataFieldNumber = 5;
  const ::std::string& file_data() const;
  void set_file_data(const ::std::string& value);
  #if LANG_CXX11
  void set_file_data(::std::string&& value);
  #endif
  void set_file_data(const char* value);
  void set_file_data(const void* value, size_t size);
  ::std::string* mutable_file_data();
  ::std::string* release_file_data();
  void set_allocated_file_data(::std::string* file_data);

  // uint32 result_code = 1;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // uint32 user_id = 3;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // uint32 offset = 4;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::internal::ArenaStringPtr file_data_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFilePullDataRspImpl();
};
// -------------------------------------------------------------------

class IMFileReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileReq) */ {
 public:
  IMFileReq();
  virtual ~IMFileReq();

  IMFileReq(const IMFileReq& from);

  inline IMFileReq& operator=(const IMFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileReq(IMFileReq&& from) noexcept
    : IMFileReq() {
    *this = ::std::move(from);
  }

  inline IMFileReq& operator=(IMFileReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileReq* internal_default_instance() {
    return reinterpret_cast<const IMFileReq*>(
               &_IMFileReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(IMFileReq* other);
  friend void swap(IMFileReq& a, IMFileReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileReq* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileReq& from);
  void MergeFrom(const IMFileReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_name = 3;
  void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // uint32 file_size = 4;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // .IM.BaseDefine.TransferFileType trans_mode = 5;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 5;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint32 file_size_;
  int trans_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileReqImpl();
};
// -------------------------------------------------------------------

class IMFileRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileRsp) */ {
 public:
  IMFileRsp();
  virtual ~IMFileRsp();

  IMFileRsp(const IMFileRsp& from);

  inline IMFileRsp& operator=(const IMFileRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileRsp(IMFileRsp&& from) noexcept
    : IMFileRsp() {
    *this = ::std::move(from);
  }

  inline IMFileRsp& operator=(IMFileRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileRsp*>(
               &_IMFileRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(IMFileRsp* other);
  friend void swap(IMFileRsp& a, IMFileRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileRsp& from);
  void MergeFrom(const IMFileRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // string file_name = 4;
  void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // string task_id = 5;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // uint32 result_code = 1;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // uint32 from_user_id = 2;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 2;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // uint32 to_user_id = 3;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 3;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // .IM.BaseDefine.TransferFileType trans_mode = 7;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  int trans_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileRspImpl();
};
// -------------------------------------------------------------------

class IMFileNotify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileNotify) */ {
 public:
  IMFileNotify();
  virtual ~IMFileNotify();

  IMFileNotify(const IMFileNotify& from);

  inline IMFileNotify& operator=(const IMFileNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileNotify(IMFileNotify&& from) noexcept
    : IMFileNotify() {
    *this = ::std::move(from);
  }

  inline IMFileNotify& operator=(IMFileNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileNotify* internal_default_instance() {
    return reinterpret_cast<const IMFileNotify*>(
               &_IMFileNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(IMFileNotify* other);
  friend void swap(IMFileNotify& a, IMFileNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileNotify& from);
  void MergeFrom(const IMFileNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // string file_name = 3;
  void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // string task_id = 5;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // uint32 file_size = 4;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // .IM.BaseDefine.TransferFileType trans_mode = 7;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // uint32 offline_ready = 8;
  void clear_offline_ready();
  static const int kOfflineReadyFieldNumber = 8;
  ::google::protobuf::uint32 offline_ready() const;
  void set_offline_ready(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint32 file_size_;
  int trans_mode_;
  ::google::protobuf::uint32 offline_ready_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileNotifyImpl();
};
// -------------------------------------------------------------------

class IMFileHasOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineReq) */ {
 public:
  IMFileHasOfflineReq();
  virtual ~IMFileHasOfflineReq();

  IMFileHasOfflineReq(const IMFileHasOfflineReq& from);

  inline IMFileHasOfflineReq& operator=(const IMFileHasOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileHasOfflineReq(IMFileHasOfflineReq&& from) noexcept
    : IMFileHasOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileHasOfflineReq& operator=(IMFileHasOfflineReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileHasOfflineReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileHasOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileHasOfflineReq*>(
               &_IMFileHasOfflineReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(IMFileHasOfflineReq* other);
  friend void swap(IMFileHasOfflineReq& a, IMFileHasOfflineReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineReq* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileHasOfflineReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileHasOfflineReq& from);
  void MergeFrom(const IMFileHasOfflineReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileHasOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes attach_data = 20;
  void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  const ::std::string& attach_data() const;
  void set_attach_data(const ::std::string& value);
  #if LANG_CXX11
  void set_attach_data(::std::string&& value);
  #endif
  void set_attach_data(const char* value);
  void set_attach_data(const void* value, size_t size);
  ::std::string* mutable_attach_data();
  ::std::string* release_attach_data();
  void set_allocated_attach_data(::std::string* attach_data);

  // uint32 user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr attach_data_;
  ::google::protobuf::uint32 user_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileHasOfflineReqImpl();
};
// -------------------------------------------------------------------

class IMFileHasOfflineRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineRsp) */ {
 public:
  IMFileHasOfflineRsp();
  virtual ~IMFileHasOfflineRsp();

  IMFileHasOfflineRsp(const IMFileHasOfflineRsp& from);

  inline IMFileHasOfflineRsp& operator=(const IMFileHasOfflineRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileHasOfflineRsp(IMFileHasOfflineRsp&& from) noexcept
    : IMFileHasOfflineRsp() {
    *this = ::std::move(from);
  }

  inline IMFileHasOfflineRsp& operator=(IMFileHasOfflineRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileHasOfflineRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileHasOfflineRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileHasOfflineRsp*>(
               &_IMFileHasOfflineRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(IMFileHasOfflineRsp* other);
  friend void swap(IMFileHasOfflineRsp& a, IMFileHasOfflineRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileHasOfflineRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileHasOfflineRsp& from);
  void MergeFrom(const IMFileHasOfflineRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileHasOfflineRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
  int offline_file_list_size() const;
  void clear_offline_file_list();
  static const int kOfflineFileListFieldNumber = 2;
  const ::IM::BaseDefine::OfflineFileInfo& offline_file_list(int index) const;
  ::IM::BaseDefine::OfflineFileInfo* mutable_offline_file_list(int index);
  ::IM::BaseDefine::OfflineFileInfo* add_offline_file_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
      mutable_offline_file_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
      offline_file_list() const;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 3;
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // bytes attach_data = 20;
  void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  const ::std::string& attach_data() const;
  void set_attach_data(const ::std::string& value);
  #if LANG_CXX11
  void set_attach_data(::std::string&& value);
  #endif
  void set_attach_data(const char* value);
  void set_attach_data(const void* value, size_t size);
  ::std::string* mutable_attach_data();
  ::std::string* release_attach_data();
  void set_allocated_attach_data(::std::string* attach_data);

  // uint32 user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo > offline_file_list_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::internal::ArenaStringPtr attach_data_;
  ::google::protobuf::uint32 user_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileHasOfflineRspImpl();
};
// -------------------------------------------------------------------

class IMFileAddOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileAddOfflineReq) */ {
 public:
  IMFileAddOfflineReq();
  virtual ~IMFileAddOfflineReq();

  IMFileAddOfflineReq(const IMFileAddOfflineReq& from);

  inline IMFileAddOfflineReq& operator=(const IMFileAddOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileAddOfflineReq(IMFileAddOfflineReq&& from) noexcept
    : IMFileAddOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileAddOfflineReq& operator=(IMFileAddOfflineReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileAddOfflineReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileAddOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileAddOfflineReq*>(
               &_IMFileAddOfflineReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(IMFileAddOfflineReq* other);
  friend void swap(IMFileAddOfflineReq& a, IMFileAddOfflineReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileAddOfflineReq* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileAddOfflineReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileAddOfflineReq& from);
  void MergeFrom(const IMFileAddOfflineReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileAddOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 3;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // string file_name = 4;
  void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // uint32 file_size = 5;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileAddOfflineReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint32 file_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileAddOfflineReqImpl();
};
// -------------------------------------------------------------------

class IMFileDelOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileDelOfflineReq) */ {
 public:
  IMFileDelOfflineReq();
  virtual ~IMFileDelOfflineReq();

  IMFileDelOfflineReq(const IMFileDelOfflineReq& from);

  inline IMFileDelOfflineReq& operator=(const IMFileDelOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileDelOfflineReq(IMFileDelOfflineReq&& from) noexcept
    : IMFileDelOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileDelOfflineReq& operator=(IMFileDelOfflineReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IMFileDelOfflineReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileDelOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileDelOfflineReq*>(
               &_IMFileDelOfflineReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(IMFileDelOfflineReq* other);
  friend void swap(IMFileDelOfflineReq& a, IMFileDelOfflineReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileDelOfflineReq* New() const PROTOBUF_FINAL { return New(NULL); }

  IMFileDelOfflineReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IMFileDelOfflineReq& from);
  void MergeFrom(const IMFileDelOfflineReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileDelOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_id = 3;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileDelOfflineReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
  friend void ::protobuf_IM_2eFile_2eproto::InitDefaultsIMFileDelOfflineReqImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IMFileLoginReq

// uint32 user_id = 1;
inline void IMFileLoginReq::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileLoginReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.user_id)
  return user_id_;
}
inline void IMFileLoginReq::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.user_id)
}

// string task_id = 2;
inline void IMFileLoginReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileLoginReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileLoginReq::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.task_id)
}
#if LANG_CXX11
inline void IMFileLoginReq::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileLoginReq.task_id)
}
#endif
inline void IMFileLoginReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileLoginReq.task_id)
}
inline void IMFileLoginReq::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileLoginReq.task_id)
}
inline ::std::string* IMFileLoginReq::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileLoginReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginReq.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginReq.task_id)
}

// .IM.BaseDefine.ClientFileRole file_role = 3;
inline void IMFileLoginReq::clear_file_role() {
  file_role_ = 0;
}
inline ::IM::BaseDefine::ClientFileRole IMFileLoginReq::file_role() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.file_role)
  return static_cast< ::IM::BaseDefine::ClientFileRole >(file_role_);
}
inline void IMFileLoginReq::set_file_role(::IM::BaseDefine::ClientFileRole value) {
  
  file_role_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.file_role)
}

// -------------------------------------------------------------------

// IMFileLoginRsp

// uint32 result_code = 1;
inline void IMFileLoginRsp::clear_result_code() {
  result_code_ = 0u;
}
inline ::google::protobuf::uint32 IMFileLoginRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.result_code)
  return result_code_;
}
inline void IMFileLoginRsp::set_result_code(::google::protobuf::uint32 value) {
  
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.result_code)
}

// string task_id = 2;
inline void IMFileLoginRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileLoginRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileLoginRsp::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.task_id)
}
#if LANG_CXX11
inline void IMFileLoginRsp::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileLoginRsp.task_id)
}
#endif
inline void IMFileLoginRsp::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileLoginRsp.task_id)
}
inline void IMFileLoginRsp::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileLoginRsp.task_id)
}
inline ::std::string* IMFileLoginRsp::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileLoginRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginRsp.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginRsp.task_id)
}

// -------------------------------------------------------------------

// IMFileState

// .IM.BaseDefine.ClientFileState state = 1;
inline void IMFileState::clear_state() {
  state_ = 0;
}
inline ::IM::BaseDefine::ClientFileState IMFileState::state() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.state)
  return static_cast< ::IM::BaseDefine::ClientFileState >(state_);
}
inline void IMFileState::set_state(::IM::BaseDefine::ClientFileState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.state)
}

// string task_id = 2;
inline void IMFileState::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileState::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileState::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.task_id)
}
#if LANG_CXX11
inline void IMFileState::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileState.task_id)
}
#endif
inline void IMFileState::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileState.task_id)
}
inline void IMFileState::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileState.task_id)
}
inline ::std::string* IMFileState::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileState.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileState::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileState.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileState::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileState.task_id)
}

// uint32 user_id = 3;
inline void IMFileState::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileState::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.user_id)
  return user_id_;
}
inline void IMFileState::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.user_id)
}

// -------------------------------------------------------------------

// IMFilePullDataReq

// string task_id = 1;
inline void IMFilePullDataReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFilePullDataReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFilePullDataReq::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.task_id)
}
#if LANG_CXX11
inline void IMFilePullDataReq::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFilePullDataReq.task_id)
}
#endif
inline void IMFilePullDataReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataReq.task_id)
}
inline void IMFilePullDataReq::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataReq.task_id)
}
inline ::std::string* IMFilePullDataReq::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataReq.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataReq.task_id)
}

// uint32 user_id = 2;
inline void IMFilePullDataReq::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFilePullDataReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.user_id)
  return user_id_;
}
inline void IMFilePullDataReq::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.user_id)
}

// .IM.BaseDefine.TransferFileType trans_mode = 3;
inline void IMFilePullDataReq::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFilePullDataReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFilePullDataReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.trans_mode)
}

// uint32 offset = 4;
inline void IMFilePullDataReq::clear_offset() {
  offset_ = 0u;
}
inline ::google::protobuf::uint32 IMFilePullDataReq::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.offset)
  return offset_;
}
inline void IMFilePullDataReq::set_offset(::google::protobuf::uint32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.offset)
}

// uint32 data_size = 5;
inline void IMFilePullDataReq::clear_data_size() {
  data_size_ = 0u;
}
inline ::google::protobuf::uint32 IMFilePullDataReq::data_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.data_size)
  return data_size_;
}
inline void IMFilePullDataReq::set_data_size(::google::protobuf::uint32 value) {
  
  data_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.data_size)
}

// -------------------------------------------------------------------

// IMFilePullDataRsp

// uint32 result_code = 1;
inline void IMFilePullDataRsp::clear_result_code() {
  result_code_ = 0u;
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.result_code)
  return result_code_;
}
inline void IMFilePullDataRsp::set_result_code(::google::protobuf::uint32 value) {
  
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.result_code)
}

// string task_id = 2;
inline void IMFilePullDataRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFilePullDataRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.task_id)
  return task_id_.GetNoArena();
}
inline void IMFilePullDataRsp::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.task_id)
}
#if LANG_CXX11
inline void IMFilePullDataRsp::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFilePullDataRsp.task_id)
}
#endif
inline void IMFilePullDataRsp::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataRsp.task_id)
}
inline void IMFilePullDataRsp::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataRsp.task_id)
}
inline ::std::string* IMFilePullDataRsp::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.task_id)
}

// uint32 user_id = 3;
inline void IMFilePullDataRsp::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.user_id)
  return user_id_;
}
inline void IMFilePullDataRsp::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.user_id)
}

// uint32 offset = 4;
inline void IMFilePullDataRsp::clear_offset() {
  offset_ = 0u;
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.offset)
  return offset_;
}
inline void IMFilePullDataRsp::set_offset(::google::protobuf::uint32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.offset)
}

// bytes file_data = 5;
inline void IMFilePullDataRsp::clear_file_data() {
  file_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFilePullDataRsp::file_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.file_data)
  return file_data_.GetNoArena();
}
inline void IMFilePullDataRsp::set_file_data(const ::std::string& value) {
  
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.file_data)
}
#if LANG_CXX11
inline void IMFilePullDataRsp::set_file_data(::std::string&& value) {
  
  file_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFilePullDataRsp.file_data)
}
#endif
inline void IMFilePullDataRsp::set_file_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataRsp.file_data)
}
inline void IMFilePullDataRsp::set_file_data(const void* value, size_t size) {
  
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataRsp.file_data)
}
inline ::std::string* IMFilePullDataRsp::mutable_file_data() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.file_data)
  return file_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataRsp::release_file_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.file_data)
  
  return file_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_allocated_file_data(::std::string* file_data) {
  if (file_data != NULL) {
    
  } else {
    
  }
  file_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.file_data)
}

// -------------------------------------------------------------------

// IMFileReq

// uint32 from_user_id = 1;
inline void IMFileReq::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.from_user_id)
  return from_user_id_;
}
inline void IMFileReq::set_from_user_id(::google::protobuf::uint32 value) {
  
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileReq::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.to_user_id)
  return to_user_id_;
}
inline void IMFileReq::set_to_user_id(::google::protobuf::uint32 value) {
  
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.to_user_id)
}

// string file_name = 3;
inline void IMFileReq::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileReq::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_name)
}
#if LANG_CXX11
inline void IMFileReq::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileReq.file_name)
}
#endif
inline void IMFileReq::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileReq.file_name)
}
inline void IMFileReq::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileReq.file_name)
}
inline ::std::string* IMFileReq::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileReq.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileReq.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileReq.file_name)
}

// uint32 file_size = 4;
inline void IMFileReq::clear_file_size() {
  file_size_ = 0u;
}
inline ::google::protobuf::uint32 IMFileReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_size)
  return file_size_;
}
inline void IMFileReq::set_file_size(::google::protobuf::uint32 value) {
  
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_size)
}

// .IM.BaseDefine.TransferFileType trans_mode = 5;
inline void IMFileReq::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFileReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.trans_mode)
}

// -------------------------------------------------------------------

// IMFileRsp

// uint32 result_code = 1;
inline void IMFileRsp::clear_result_code() {
  result_code_ = 0u;
}
inline ::google::protobuf::uint32 IMFileRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.result_code)
  return result_code_;
}
inline void IMFileRsp::set_result_code(::google::protobuf::uint32 value) {
  
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.result_code)
}

// uint32 from_user_id = 2;
inline void IMFileRsp::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileRsp::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.from_user_id)
  return from_user_id_;
}
inline void IMFileRsp::set_from_user_id(::google::protobuf::uint32 value) {
  
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.from_user_id)
}

// uint32 to_user_id = 3;
inline void IMFileRsp::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileRsp::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.to_user_id)
  return to_user_id_;
}
inline void IMFileRsp::set_to_user_id(::google::protobuf::uint32 value) {
  
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.to_user_id)
}

// string file_name = 4;
inline void IMFileRsp::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileRsp::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileRsp::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.file_name)
}
#if LANG_CXX11
inline void IMFileRsp::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileRsp.file_name)
}
#endif
inline void IMFileRsp::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileRsp.file_name)
}
inline void IMFileRsp::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileRsp.file_name)
}
inline ::std::string* IMFileRsp::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileRsp::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.file_name)
}

// string task_id = 5;
inline void IMFileRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileRsp::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.task_id)
}
#if LANG_CXX11
inline void IMFileRsp::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileRsp.task_id)
}
#endif
inline void IMFileRsp::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileRsp.task_id)
}
inline void IMFileRsp::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileRsp.task_id)
}
inline ::std::string* IMFileRsp::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline const ::IM::BaseDefine::IpAddr& IMFileRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_;
}

// .IM.BaseDefine.TransferFileType trans_mode = 7;
inline void IMFileRsp::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFileRsp::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileRsp::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.trans_mode)
}

// -------------------------------------------------------------------

// IMFileNotify

// uint32 from_user_id = 1;
inline void IMFileNotify::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileNotify::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.from_user_id)
  return from_user_id_;
}
inline void IMFileNotify::set_from_user_id(::google::protobuf::uint32 value) {
  
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileNotify::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileNotify::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.to_user_id)
  return to_user_id_;
}
inline void IMFileNotify::set_to_user_id(::google::protobuf::uint32 value) {
  
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.to_user_id)
}

// string file_name = 3;
inline void IMFileNotify::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileNotify::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileNotify::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_name)
}
#if LANG_CXX11
inline void IMFileNotify::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileNotify.file_name)
}
#endif
inline void IMFileNotify::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileNotify.file_name)
}
inline void IMFileNotify::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileNotify.file_name)
}
inline ::std::string* IMFileNotify::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileNotify::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.file_name)
}

// uint32 file_size = 4;
inline void IMFileNotify::clear_file_size() {
  file_size_ = 0u;
}
inline ::google::protobuf::uint32 IMFileNotify::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_size)
  return file_size_;
}
inline void IMFileNotify::set_file_size(::google::protobuf::uint32 value) {
  
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_size)
}

// string task_id = 5;
inline void IMFileNotify::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileNotify::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileNotify::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.task_id)
}
#if LANG_CXX11
inline void IMFileNotify::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileNotify.task_id)
}
#endif
inline void IMFileNotify::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileNotify.task_id)
}
inline void IMFileNotify::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileNotify.task_id)
}
inline ::std::string* IMFileNotify::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileNotify::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileNotify::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline const ::IM::BaseDefine::IpAddr& IMFileNotify::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileNotify::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileNotify.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileNotify::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_;
}

// .IM.BaseDefine.TransferFileType trans_mode = 7;
inline void IMFileNotify::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFileNotify::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileNotify::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.trans_mode)
}

// uint32 offline_ready = 8;
inline void IMFileNotify::clear_offline_ready() {
  offline_ready_ = 0u;
}
inline ::google::protobuf::uint32 IMFileNotify::offline_ready() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.offline_ready)
  return offline_ready_;
}
inline void IMFileNotify::set_offline_ready(::google::protobuf::uint32 value) {
  
  offline_ready_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.offline_ready)
}

// -------------------------------------------------------------------

// IMFileHasOfflineReq

// uint32 user_id = 1;
inline void IMFileHasOfflineReq::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileHasOfflineReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.user_id)
  return user_id_;
}
inline void IMFileHasOfflineReq::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.user_id)
}

// bytes attach_data = 20;
inline void IMFileHasOfflineReq::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileHasOfflineReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.attach_data)
  return attach_data_.GetNoArena();
}
inline void IMFileHasOfflineReq::set_attach_data(const ::std::string& value) {
  
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.attach_data)
}
#if LANG_CXX11
inline void IMFileHasOfflineReq::set_attach_data(::std::string&& value) {
  
  attach_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileHasOfflineReq.attach_data)
}
#endif
inline void IMFileHasOfflineReq::set_attach_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileHasOfflineReq.attach_data)
}
inline void IMFileHasOfflineReq::set_attach_data(const void* value, size_t size) {
  
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileHasOfflineReq.attach_data)
}
inline ::std::string* IMFileHasOfflineReq::mutable_attach_data() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineReq.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileHasOfflineReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineReq.attach_data)
  
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    
  } else {
    
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineReq.attach_data)
}

// -------------------------------------------------------------------

// IMFileHasOfflineRsp

// uint32 user_id = 1;
inline void IMFileHasOfflineRsp::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileHasOfflineRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.user_id)
  return user_id_;
}
inline void IMFileHasOfflineRsp::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.user_id)
}

// repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
inline int IMFileHasOfflineRsp::offline_file_list_size() const {
  return offline_file_list_.size();
}
inline const ::IM::BaseDefine::OfflineFileInfo& IMFileHasOfflineRsp::offline_file_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Get(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::mutable_offline_file_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Mutable(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::add_offline_file_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
IMFileHasOfflineRsp::mutable_offline_file_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return &offline_file_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
IMFileHasOfflineRsp::offline_file_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_;
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
inline int IMFileHasOfflineRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline const ::IM::BaseDefine::IpAddr& IMFileHasOfflineRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileHasOfflineRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileHasOfflineRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_;
}

// bytes attach_data = 20;
inline void IMFileHasOfflineRsp::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileHasOfflineRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.attach_data)
  return attach_data_.GetNoArena();
}
inline void IMFileHasOfflineRsp::set_attach_data(const ::std::string& value) {
  
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.attach_data)
}
#if LANG_CXX11
inline void IMFileHasOfflineRsp::set_attach_data(::std::string&& value) {
  
  attach_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileHasOfflineRsp.attach_data)
}
#endif
inline void IMFileHasOfflineRsp::set_attach_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline void IMFileHasOfflineRsp::set_attach_data(const void* value, size_t size) {
  
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline ::std::string* IMFileHasOfflineRsp::mutable_attach_data() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileHasOfflineRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineRsp.attach_data)
  
  return attach_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    
  } else {
    
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineRsp.attach_data)
}

// -------------------------------------------------------------------

// IMFileAddOfflineReq

// uint32 from_user_id = 1;
inline void IMFileAddOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.from_user_id)
  return from_user_id_;
}
inline void IMFileAddOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileAddOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.to_user_id)
  return to_user_id_;
}
inline void IMFileAddOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.to_user_id)
}

// string task_id = 3;
inline void IMFileAddOfflineReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileAddOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileAddOfflineReq::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.task_id)
}
#if LANG_CXX11
inline void IMFileAddOfflineReq::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileAddOfflineReq.task_id)
}
#endif
inline void IMFileAddOfflineReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileAddOfflineReq.task_id)
}
inline void IMFileAddOfflineReq::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileAddOfflineReq.task_id)
}
inline ::std::string* IMFileAddOfflineReq::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileAddOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.task_id)
}

// string file_name = 4;
inline void IMFileAddOfflineReq::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileAddOfflineReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileAddOfflineReq::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_name)
}
#if LANG_CXX11
inline void IMFileAddOfflineReq::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileAddOfflineReq.file_name)
}
#endif
inline void IMFileAddOfflineReq::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileAddOfflineReq.file_name)
}
inline void IMFileAddOfflineReq::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileAddOfflineReq.file_name)
}
inline ::std::string* IMFileAddOfflineReq::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileAddOfflineReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.file_name)
}

// uint32 file_size = 5;
inline void IMFileAddOfflineReq::clear_file_size() {
  file_size_ = 0u;
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_size)
  return file_size_;
}
inline void IMFileAddOfflineReq::set_file_size(::google::protobuf::uint32 value) {
  
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_size)
}

// -------------------------------------------------------------------

// IMFileDelOfflineReq

// uint32 from_user_id = 1;
inline void IMFileDelOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.from_user_id)
  return from_user_id_;
}
inline void IMFileDelOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileDelOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.to_user_id)
  return to_user_id_;
}
inline void IMFileDelOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.to_user_id)
}

// string task_id = 3;
inline void IMFileDelOfflineReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IMFileDelOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileDelOfflineReq::set_task_id(const ::std::string& value) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.task_id)
}
#if LANG_CXX11
inline void IMFileDelOfflineReq::set_task_id(::std::string&& value) {
  
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileDelOfflineReq.task_id)
}
#endif
inline void IMFileDelOfflineReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileDelOfflineReq.task_id)
}
inline void IMFileDelOfflineReq::set_task_id(const char* value, size_t size) {
  
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileDelOfflineReq.task_id)
}
inline ::std::string* IMFileDelOfflineReq::mutable_task_id() {
  
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileDelOfflineReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileDelOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileDelOfflineReq.task_id)
  
  return task_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileDelOfflineReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    
  } else {
    
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileDelOfflineReq.task_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace File
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eFile_2eproto__INCLUDED
